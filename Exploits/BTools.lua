local plr = game:GetService("Players").LocalPlayer
local btools;
local syncapi;

print'waiting'

repeat task.wait() until plr.Backpack:FindFirstChild("ServerEndpoint", true) and plr.Backpack:FindFirstChild("ServerEndpoint", true):IsA("RemoteFunction")

print'got sync'

syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
btools = syncapi.Parent.Parent

local parts = {}

local Movement = {
	Position = CFrame.new(0, 5, 0),
	FakePosition = CFrame.new(0, 5, 0),
	MouseHit = CFrame.identity,
	Jumping = false,
	Falling = false,
	Walking = false,
	Flying = false,
}

local oldmainpos, walkspeed, gravityvelocity = Movement.Position, 30, 0
local w, a, s, d = false, false, false, false

local movementkeys = {
	w = function(up, io)
		w = not up
	end,
	a = function(up, io)
		a = not up
	end,
	s = function(up, io)
		s = not up
	end,
	d = function(up, io)
		d = not up
	end,
	f = function(up, io)
		if(not up)then
			Movement.Flying = not Movement.Flying
		end
	end,
	space = function(up, io)
		if(not up and not Movement.Falling and not Movement.Jumping and not Movement.Flying)then
			Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis/2)
			gravityvelocity = (1/60)*30
		end
	end,
}

local mouse = plr:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(false, io)
	end
end)

game:GetService("UserInputService").InputEnded:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(true, io)
	end
end)

local campart = Instance.new("Part")
campart.Size = Vector3.zero
campart.Transparency = 1
campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)

game:GetService("RunService").RenderStepped:Connect(function(dt)
	if(not campart) or (not pcall(function()
			campart.Parent = nil
			campart.CFrame = campart.CFrame
		end))then
		pcall(game.Destroy, campart)
		campart = Instance.new("Part")
		campart.Size = Vector3.zero
		campart.Transparency = 1
		campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)
	end
	pcall(function()
		workspace.CurrentCamera.CameraSubject = campart
	end)
end)

local realRotation = CFrame.identity
local momentum = 0
local momentummax = 40
local momentumspeed = 5
local walkingtime = os.clock()

local lastframe = os.clock()
local deltamult = 1

local function deltaclamp(val)
	return math.clamp(val*deltamult, 0, 1)
end

game:GetService("RunService").RenderStepped:Connect(function(delta)
	deltamult = 60*(os.clock() - lastframe)
	lastframe = os.clock()
	campart.CFrame = campart.CFrame:Lerp(Movement.Position*CFrame.new(0,1.5,0), deltaclamp(.3))

	oldmainpos = Movement.Position
	local shiftlock =  game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter

	if(not Movement.Flying)then
		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {workspace.Terrain}
		local ray = workspace:Raycast(Movement.Position.Position, Vector3.new(0,-3.1,0), param)
		if(ray)then
			Movement.Position = Movement.Position * CFrame.new(0,ray.Position.Y-Movement.Position.Y+3,0)
			gravityvelocity = 0
		else
			gravityvelocity = gravityvelocity - (((1/60)*1.4*(workspace.Gravity/196.2))*deltamult)
		end
	else
		gravityvelocity = 0
	end

	if(w or a or s or d)and(walkspeed>0)then
		Movement.Walking = true
	else
		Movement.Walking = false
		walkingtime = os.clock()
		momentum = 0
	end

	local fakewalkspeed = walkspeed

	if(Movement.Flying)then
		momentum = math.clamp((os.clock() - walkingtime) * momentumspeed, 0, momentummax)
	end
	fakewalkspeed = fakewalkspeed + momentum

	if(w and d)or(w and a)or(s and d)or(s and a)then
		fakewalkspeed = fakewalkspeed/1.4
	end

	local camlook = workspace.CurrentCamera.CFrame.LookVector

	if(Movement.Walking)and(not shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	elseif(shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	end

	if(w)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(a)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end
	if(s)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(d)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end

	if(not shiftlock)and(Movement.Position.X ~= oldmainpos.X)and(Movement.Position.Z ~= oldmainpos.Z)then
		Movement.Position = CFrame.new(Movement.Position.Position) * realRotation.Rotation

		if(Movement.Walking)and(not Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, 0, look.Z)), deltaclamp(math.pi/16))
		elseif(Movement.Walking)and(Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, look.Y, look.Z)), deltaclamp(math.pi/16))
		end

		realRotation = Movement.Position.Rotation
	end

	if(Movement.Position.Y < -200)then
		Movement.Position = CFrame.new(0,20,0)
		gravityvelocity = 0
	end

	Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis*gravityvelocity)

	if(not Movement.Flying)then
		if(oldmainpos.Y > Movement.Position.Y)then
			Movement.Falling = true
			Movement.Jumping = false
		elseif(oldmainpos.Y < Movement.Position.Y)then
			Movement.Falling = false
			Movement.Jumping = true
		else
			Movement.Falling = false
			Movement.Jumping = false
		end
	else
		Movement.Falling = false
		Movement.Jumping = false
	end
end)

local limbs = {}
local cframes = {}

local sizes = {
	["Torso"] = Vector3.new(2, 2, 1),
	["Right Arm"] = Vector3.new(1, 2, 1),
	["Left Arm"] = Vector3.new(1, 2, 1),
	["Right Leg"] = Vector3.new(1, 2, 1),
	["Left Leg"] = Vector3.new(1, 2, 1),
	["Head"] = Vector3.new(1, 1, 1),
}
local colors = {
	["Torso"] = Color3.new(1, .3, .3)
}

local offsets = {
	["Torso"] = CFrame.identity,
	["Left Leg"] = CFrame.new(-.5, -2, 0),
	["Right Leg"] = CFrame.new(.5, -2, 0),
	["Right Arm"] = CFrame.new(1.5, 0, 0),
	["Left Arm"] = CFrame.new(-1.5, 0, 0),
	["Head"] = CFrame.new(0, 1.5, 0),
}
local origoffsets = table.clone(offsets)
local replicatedparts = {}

local queueforremoval = {}

local function destroy(obj)
	local orig = obj
	
	if(replicatedparts[obj])then obj = replicatedparts[obj] end
	replicatedparts[orig] = nil
	
	orig:Destroy()
	
	table.remove(parts, table.find(parts, orig))
	table.insert(queueforremoval, obj)
end

local function newpart()
	local p = syncapi:InvokeServer('CreatePart', 'Normal', CFrame.new(9e9, 9e9, 9e9), workspace.Terrain)
	p.Parent = game:GetService("ReplicatedStorage")
	p.Anchored = true
	
	local fakepart = Instance.new("Part", workspace.Terrain)
	fakepart.CFrame = CFrame.new(9e9, 9e9, 9e9)
	fakepart.Anchored = true
	fakepart.TopSurface = Enum.SurfaceType.Smooth;
	fakepart.BottomSurface = Enum.SurfaceType.Smooth;
	table.insert(parts, fakepart)
	replicatedparts[fakepart] = p
	
	return fakepart
end

local function createlimb(name)
	local limb = newpart()
	limbs[name] = limb

	limb.Material = Enum.Material.Glass
	limb.Transparency = .25
	limb.Anchored = true
	limb.Color = colors[name] or Color3.new(1,1,1)
	limb.Size = sizes[name] or Vector3.zero
	limb.CFrame = cframes[name] or CFrame.identity
	
	repeat task.wait() until limbs[name] ~= limb
	destroy(limb)
end

local function PlaySound(a, b, c, d, e)
	local temp = Instance.new("Attachment")
	temp.Name = ""

	temp.CFrame = b
	local audio = Instance.new("Sound", temp)
	audio.Name = ""
	audio.PlayOnRemove = true
	audio.Pitch = c
	audio.SoundId = a
	audio.Volume = d
	temp.Parent = workspace.Terrain
	if e then
		audio.TimePosition = e
	end
	temp:Destroy()
end

local LightningBolt = {}
local ActiveEffects = {}
local Module = {
	Effect = {}
}
local tospin = {}
function Lerp3D(a, b, c, DeltaTime)
	return a:Lerp(b, 1 - c ^ DeltaTime)
end
function LerpNum(a, b, c, DeltaTime)
	return a + (b - a) * (1 - c ^ DeltaTime)
end
function tween(a,info, props)
	local re = game:GetService("TweenService"):Create(a, TweenInfo.new(table.unpack(info)), props)
	re:Play()
	return re
end
--effect2(StartProperties:{}, TweenList:{TweenInfo:{}, TweenProperties{}, TweenSettings:{Yield}})
function Module.Effect.TW(tbl)
	local dprops = tbl.StartProps
	local list = tbl.TweenList
	local new = newpart()
	new.Size = dprops.Size or Vector3.new()
	new.Material=dprops.Neon or "Neon"
	for prop in pairs(dprops) do
		new[prop]=dprops[prop]
	end
	new.Parent=workspace
	if tbl.Spin  then
		tospin[new] = tbl.Spin
	end
	for index, info in ipairs(list) do
		local Settings =	info.Settings or {}
		if Settings.Spin then
			tospin[new] = Settings.Spin
		end
		local tw = tween(new, info.TweenInfo, info.TweenProperties)
		if Settings.MulSpin then
			for i = 1, Settings.MulSpin do
				tospin[new] = tbl.Spin * tbl.Spin
			end
		end
		if Settings.Yield then
			tw.Completed:Wait()
		end
		if index==#list or new == nil or new.Parent~=workspace then
			destroy(new)
			break
		end
	end
end
function Module.Effect.colorshift3(tbl)
	local a = newpart()
	a.CFrame=tbl.CF
	a.Size=tbl.Size
	a.Color=tbl.C1
	a.Material="Neon"
	a.Parent=workspace
	game:GetService("Debris"):AddItem(a, tbl.time)
	tween(a, {tbl.time}, {Transparency=1})
	tween(a, {tbl.time/2}, {Color=tbl.C2}).Completed:Wait()
	tween(a, {tbl.time/2}, {Color=tbl.C3})
end
function Module.Effect.new(tbl)	
	tbl.Color1 = tbl.Color1 or Color3.new()
	tbl.Color2 = tbl.Color2 or Color3.new()
	tbl.Size1=tbl.Size1 Vector3.new(5,5,5)
	tbl.Size2=tbl.Size2 or Vector3.new(5,5,5)
	tbl.StartCF=tbl.StartCF or CFrame.new()
	tbl.LifeTime=(tbl.LifeTime or 100)
	tbl.Shape=tbl.Shape or "Part"
	tbl.sbm = tbl.sbm or 1
	tbl.mbm = tbl.mbm or 1
	tbl.b1 = 1+tbl.mbm/50
	tbl.b2 = 1+tbl.sbm/50
	tbl.radX = tbl.radX or 0
	tbl.radY = tbl.radY or 0
	tbl.radZ = tbl.radZ or 0
	tbl.Size2=tbl.Size2 or Vector3.new()
	tbl.Transparency1=tbl.Transparency1 or 0
	tbl.Transparency2=tbl.Transparency2 or 0
	local Part = newpart()
	Part.CanCollide = false
	Part.CanTouch = false
	Part.CanQuery = false
	Part.Anchored = true
	Part.Name = ""
	Part.CFrame = tbl.StartCF or CFrame.new()
	Part.Size = tbl.DSize or tbl.Size1 or Vector3.new()
	Part.Transparency = tbl.Transparency1  or 0
	Part.Color =  tbl.DColor  or tbl.Color1 or Color3.new()
	Part.Material = tbl.DMaterial  or tbl.Material  or Enum.Material.Neon
	Part.Reflectance = tbl.Reflectance or 0
	if tbl.MoveTo then
		if tbl.Boomerang then
			tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime*tbl.b1
		else
			tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime
		end
	end
	if tbl.Boomerang then
		tbl.EndSize=(tbl.Size1 - tbl.Size2)*tbl.b2
	else
		tbl.EndSize=(tbl.Size1 - tbl.Size2)
	end
	tbl.EndTransparency=tbl.Transparency1-tbl.Transparency2
	table.insert(ActiveEffects, {
		["Part"] = Part,
		[2] = tbl,
		Index = 1
	})
end

local LightningBolt = {}

function Module.Effect.clear()
	for data in pairs(ActiveEffects) do
		destroy(data.Part)
	end
	table.clear(ActiveEffects)
end
function Module.Effect.Lightning(Table)
	assert(Table.Start, "Start is nil")
	assert(Table.End, "Start is nil")
	Table.Curve = Table.Curve or 0
	Table.Radius = Table.Radius or 0
	Table.LifeTime = Table.LifeTime or 1
	local A1, A2 = {}, {}
	A1.WorldPosition, A1.WorldAxis = Table.Start.p, Vector3.new()
	A2.WorldPosition, A2.WorldAxis = Table.End.p, Vector3.new()
	local self = LightningBolt.new(A1, A2, Table.Segments or 10, workspace.Terrain)
	self.Enabled = true 
	self.Attachment0, self.Attachment1 = A1, A2
	if Table.ProperCurve then
		self.CurveSize0, self.CurveSize1 = Table.Curve1 or 0,Table.Curve2 or 0
	else
		self.CurveSize0, self.CurveSize1 = -Table.Curve or 0,Table.Curve or 0
	end
	self.MinRadius, self.MaxRadius = -Table.Radius or 0, Table.Radius or 0
	self.Frequency = Table.Frequency or 1
	self.AnimationSpeed = Table.AnimationSpeed or 0
	self.Thickness = Table.Thickness or 1
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = Table.MinThickness or 1, Table.MaxThickness or 1
	self.MinTransparency, self.MaxTransparency = 0, 1
	self.PulseSpeed = Table.LifeTime or 1
	self.PulseLength = Table.LifeTime or 1
	self.FadeLength = Table.LifeTime*2 or 2
	self.ContractFrom = Table.LifeTime*20 or 20
	self.Color = Table.Color or Color3.new()
end


local Throttle = 0
local ConsecutiveFrames = 0
game:GetService("RunService").Heartbeat:Connect(function(DeltaTime)

	ConsecutiveFrames = ConsecutiveFrames + DeltaTime
	Throttle = 0
	for _ = 1,ConsecutiveFrames/(1/60) do
		ConsecutiveFrames = ConsecutiveFrames - (1/60)
		Throttle = Throttle + 1
	end
	for tt = 1, Throttle do
		for i in pairs(tospin) do
			i.CFrame=i.CFrame*tospin[i]
			if not i:IsDescendantOf(game) then
				tospin[i]=nil
			end
		end
	end
	for throttleindex = 1, Throttle do
		for i, Data in pairs(ActiveEffects) do
			local p=Data.Part
			local tbl = Data[2]
			local acttime = tbl.LifeTime
			if tbl.Boomerang then
				p.Size=p.Size-(Vector3.new((tbl.EndSize.X)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Y)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Z)*((1 - (Data.Index/acttime)*tbl.b2)))*tbl.b2)/acttime
				p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
				if tbl.Color2 then
					p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
				end
				if tbl.MoveTo ~= nil then
					local a = p.Orientation
					p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-(tbl.MovingSpeed)*((1-(Data.Index/acttime)*tbl.b1)))
					p.Orientation = a
				end
			else
				p.Size=p.Size-tbl.EndSize/acttime/2
				p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
				if tbl.Color2 then
					p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
				end
				if tbl.MoveTo ~= nil then
					local a = p.Orientation
					p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-tbl.MovingSpeed/2)
					p.Orientation = a
				end
			end
			if Data.Index >= (acttime * 2)+1 then
				table.remove(ActiveEffects, i)
				destroy(p)
			end
			Data.Index=Data.Index+1
		end
	end
end)



local clock = os.clock


function DiscretePulse(input, s, k, f, t, min, max) --input should be between 0 and 1. See https://www.desmos.com/calculator/hg5h4fpfim for demonstration.
	return math.clamp( (k)/(2*f) - math.abs( (input - t*s + 0.5*(k)) / (f) ), min, max )
end

function NoiseBetween(x, y, z, min, max)
	return min + (max - min)*(math.noise(x, y, z) + 0.5)
end

function CubicBezier(p0, p1, p2, p3, t)
	return p0*(1 - t)^3 + p1*3*t*(1 - t)^2 + p2*3*(1 - t)*t^2 + p3*t^3
end
local rng = Random.new()
local xInverse = CFrame.lookAt(Vector3.new(), Vector3.new(1, 0, 0)):inverse()

local ActiveBranches = {}

LightningBolt.__index = LightningBolt

--Small tip: You don't need to use actual Roblox Attachments below. You can also create "fake" ones as follows:

function LightningBolt.new(Attachment0, Attachment1, PartCount,parent)
	local self = setmetatable({}, LightningBolt)

	--Main (default) Properties--

	--Bolt Appearance Properties--
	self.Enabled = true --Hides bolt without destroying any parts when false
	self.Attachment0, self.Attachment1 = Attachment0, Attachment1 --Bolt originates from Attachment0 and ends at Attachment1
	self.CurveSize0, self.CurveSize1 = 0, 0 --Works similarly to beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png
	self.MinRadius, self.MaxRadius = 0, 2.4 --Governs the amplitude of fluctuations throughout the bolt
	self.Frequency = 1 --Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning
	self.AnimationSpeed = 7 --Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)
	self.Thickness = 1 --The thickness of the bolt
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = 0.2, 1 --Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt

	--Bolt Kinetic Properties--
	--Allows for fading in (or out) of the bolt with time. Can also create a "projectile" bolt
	--Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)
	--Works by passing a "wave" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)
	--See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties
	self.MinTransparency, self.MaxTransparency = 0, 1 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseSpeed = 2 --Bolt arrives at Attachment1 1/PulseSpeed seconds later. See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseLength = 1000000 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.FadeLength = 0.2 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.ContractFrom = 0.5 --Parts shorten or gro
	self.Color = Color3.new(1, 1, 1) --Can bw once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441

	--Bolt Color Properties--e a Color3 or ColorSequence
	self.ColorOffsetSpeed = 3 --Sets speed at which ColorSequence travels along Bolt

	--

	self.Parts = {} --The BoltParts which make up the Bolt


	local a0, a1 = Attachment0, Attachment1
	local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*self.CurveSize0, a1.WorldPosition - a1.WorldAxis*self.CurveSize1, a1.WorldPosition
	local PrevPoint, bezier0 = p0, p0
	local MainBranchN = PartCount or 30

	for i = 1, MainBranchN do
		local t1 = i/MainBranchN
		local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
		local NextPoint = i ~= MainBranchN and (CFrame.lookAt(bezier0, bezier1)).Position or bezier1
		local BPart = newpart()
		BPart.Anchored = true
		BPart.Color = Color3.new(1, 1, 1)
		BPart.CanTouch, BPart.CanQuery = false, false
		BPart.Material = Enum.Material.Neon
		BPart.Transparency = 1
		BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, 0, 0)
		BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
		BPart.Parent = parent
		BPart.Locked, BPart.CastShadow = true, false
		self.Parts[i] = BPart
		PrevPoint, bezier0 = NextPoint, bezier1
	end

	self.PartsHidden = false
	self.DisabledTransparency = 1
	self.StartT = clock()
	self.RanNum = math.random()*100
	self.RefIndex = #ActiveBranches + 1

	ActiveBranches[self.RefIndex] = self

	return self
end

function LightningBolt:Destroy()
	ActiveBranches[self.RefIndex] = nil

	for i = 1, #self.Parts do
		destroy(self.Parts[i])
		task.spawn(function()
			task.wait()
			table.remove(self.Parts, i)
		end)
		if i%100 == 0 then wait() end
	end
	task.spawn(function()
		repeat task.wait() until #self.Parts == 0
		table.clear(self)
		self = nil
	end)
end

local offsetAngle = math.cos(math.rad(90))

game:GetService("RunService").Heartbeat:Connect(function ()

	for _, ThisBranch in pairs(ActiveBranches) do
		if ThisBranch.Enabled == true then
			ThisBranch.PartsHidden = false
			local MinOpa, MaxOpa = 1 - ThisBranch.MaxTransparency, 1 - ThisBranch.MinTransparency
			local MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius
			local thickness = ThisBranch.Thickness
			local Parts = ThisBranch.Parts
			local PartsN = #Parts
			local RanNum = ThisBranch.RanNum
			local StartT = ThisBranch.StartT
			local spd = ThisBranch.AnimationSpeed
			local freq = ThisBranch.Frequency
			local MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier
			local a0, a1, CurveSize0, CurveSize1 = ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1
			local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*CurveSize0, a1.WorldPosition - a1.WorldAxis*CurveSize1, a1.WorldPosition
			local timePassed = clock() - StartT
			local PulseLength, PulseSpeed, FadeLength = ThisBranch.PulseLength, ThisBranch.PulseSpeed, ThisBranch.FadeLength
			local Color = ThisBranch.Color
			local ColorOffsetSpeed = ThisBranch.ColorOffsetSpeed
			local contractf = 1 - ThisBranch.ContractFrom
			local PrevPoint, bezier0 = p0, p0

			if timePassed < (PulseLength + 1) / PulseSpeed then

				for i = 1, PartsN do
					--local spd = NoiseBetween(i/PartsN, 1.5, 0.1*i/PartsN, -MinAnimationSpeed, MaxAnimationSpeed) --Can enable to have an alternative animation which doesn't shift the noisy lightning "Texture" along the bolt
					local BPart = Parts[i]
					local t1 = i/PartsN
					local Opacity = DiscretePulse(t1, PulseSpeed, PulseLength, FadeLength, timePassed, MinOpa, MaxOpa)
					local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
					local time = -timePassed --minus to ensure bolt waves travel from a0 to a1
					local input, input2 = (spd*time) + freq*10*t1 - 0.2 + RanNum*4, 5*((spd*0.01*time) / 10 + freq*t1) + RanNum*4
					local noise0 = NoiseBetween(5*input, 1.5, 5*0.2*input2, 0, 0.1*2*math.pi) + NoiseBetween(0.5*input, 1.5, 0.5*0.2*input2, 0, 0.9*2*math.pi)
					local noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)*math.exp(-5000*(t1 - 0.5)^10)
					local thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)
					local NextPoint = i ~= PartsN and (CFrame.new(bezier0, bezier1)*CFrame.Angles(0, 0, noise0)*CFrame.Angles(math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)), 0, 0)*CFrame.new(0, 0, -noise1)).Position or bezier1

					if Opacity > contractf then
						BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					elseif Opacity > contractf - 1/(PartsN*FadeLength) then
						local interp = (1 - (Opacity - (contractf - 1/(PartsN*FadeLength)))*PartsN*FadeLength)*(t1 < timePassed*PulseSpeed - 0.5*PulseLength and 1 or -1)
						BPart.Size = Vector3.new((1 - math.abs(interp))*(NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(PrevPoint + (NextPoint - PrevPoint)*(math.max(0, interp) + 0.5*(1 - math.abs(interp))), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					else
						BPart.Transparency = 1
					end

					if typeof(Color) == "Color3" then
						BPart.Color = Color
					else --ColorSequence
						t1 = (RanNum + t1 - timePassed*ColorOffsetSpeed)%1
						local keypoints = Color.Keypoints 
						for i = 1, #keypoints - 1 do --convert colorsequence onto lightning
							if keypoints[i].Time < t1 and t1 < keypoints[i+1].Time then
								BPart.Color = keypoints[i].Value:lerp(keypoints[i+1].Value, (t1 - keypoints[i].Time)/(keypoints[i+1].Time - keypoints[i].Time))
								break
							end
						end
					end

					PrevPoint, bezier0 = NextPoint, bezier1
				end

			else

				ThisBranch:Destroy()

			end

		else --Enabled = false

			if ThisBranch.PartsHidden == false then
				ThisBranch.PartsHidden = true
				local datr = ThisBranch.DisabledTransparency
				for i = 1, #ThisBranch.Parts do
					ThisBranch.Parts[i].Transparency = datr
				end
			end

		end
	end

end)

local function animate(cfs)
	for i, v in next, cfs do
		offsets[i] = offsets[i]:Lerp(origoffsets[i] * v, .1)
	end
end

function radiananglefrom(range)
	return CFrame.Angles(math.rad(math.random(-range,range)),math.rad(math.random(-range,range)),math.rad(math.random(-range,range)))
end

function randomtable(t)
	return t[math.random(#t)]
end

function randomangle()
	return CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360))
end

function mrandom(a,b)
	return Random.new():NextNumber(a or -1,b or 1)
end

function cfoffset(range)
	return CFrame.new((mrandom(-range,range)),mrandom(-range,range),mrandom(-range,range))
end

function DrawPoint(A,B)
	local Distance = (A-B).Magnitude
	return CFrame.new(A, B)*CFrame.new(0,0,-Distance/2), Distance
end
function PointLightning(Start, End, Segments, Offset)
	local Points = {}
	for i = 0, Segments do
		local Offset = Vector3.new(mrandom(-Offset,Offset),mrandom(-Offset,Offset),mrandom(-Offset,Offset))
		if i == 0 or i == Segments then
			Offset = Vector3.new()
		end
		table.insert(Points, 
			Start + (End - Start).Unit * i * (End - Start).Magnitude/Segments + Offset
		)
	end
	return Points, Offset
end

local cooldown = false
local usingarmL = true
local lookmouse = false
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe or cooldown)then return end
	if(io.KeyCode == Enum.KeyCode.E)then
		if Movement.Falling then
			return
		end
		walkspeed=0
		cooldown = true
		lookmouse = true
		usingarmL = false
		local c;c=game:GetService("RunService").Heartbeat:Connect(function()
			animate({
				["Left Arm"] = CFrame.new(0,1.1,-.5)*CFrame.Angles(math.rad(120),0,0)
			})
		end)
		task.wait(.6)
		c:Disconnect()
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = parts
		local allc = math.random(20,30)
		for i = 1, allc do
			local hit = mouse.Hit
			task.wait(.02)
			task.spawn(function()
				local dest = (Movement.Position*cfoffset(.7)).p
				task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest)*randomangle(),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(1,1,5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=15,radX=mrandom(-12,12),radY=mrandom(-12,12),radZ=mrandom(-12,12)}) end)
				local p = Movement.Position*CFrame.new(mrandom(-4,4),mrandom(8,15),mrandom(-4,4))
				local spread = Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
				local dir = (CFrame.new(p.p,hit.p).LookVector.Unit*1000 + spread*70)
				local hitray = workspace:Raycast(p.p, dir, params)
				local hit = hit
				local Normal = Vector3.new(0,1,0)
				if hitray then
					hit=CFrame.new(hitray.Position)
					Normal = hitray.Normal
				else
					hit = CFrame.new(p.p + dir)
				end
				local a = newpart()
				a.CFrame = CFrame.new(p.p, Movement.Position.p)
				a.Size=Vector3.new()
				a.Material="Glass"
				a.Color=Color3.new(1, 0.3, 0)
				a.Anchored=true
				a.CastShadow=false
				a.CastShadow=false
				a.CanQuery=false
				a.CanCollide=false
				task.spawn(function()
					local last = p.p
					local Points = PointLightning(p.p,Movement.Position.p, 8/3, .5)

					for i,v in ipairs(Points) do
						local Point, Distance = DrawPoint(last, v)
						task.spawn(function()
						Module.Effect.TW({
							StartProps = {
								CFrame=Point,
								Color=Color3.new(1,.15,0),
								Size=Vector3.new(),
								Material = "Glass"
							},
							TweenList = {
								{
									TweenInfo={.5},
									TweenProperties={Size=Vector3.new(.5,.5,Distance)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={.5,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
									TweenProperties={Transparency=1,Size=Vector3.new(0,0,Distance)},
									Settings = {Yield=true}
								},
							},
						}) end)
						last=v
						if i == #Points  then
							task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(2.5,2.5,2.5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=35}) end)
						end
						PlaySound("rbxassetid://4307214211", Point, mrandom(.8,1.2), .2)
						task.wait(.05)
					end
				end)

				tween(a, {.5}, {Size=Vector3.new(.5,.5,2)}).Completed:Wait()
				tween(a, {.5}, {CFrame=CFrame.new(p.p, hit.p)}).Completed:Wait()
				p = CFrame.new(p.p, hit.p)
				local dis = (p.p - hit.p).Magnitude



				if math.random(2)==1 then
					task.wait(.3)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)

					task.spawn(function() Module.Effect.new({StartCF=CFrame.new(p.p, hit.p) * CFrame.new(0,0,-dis/2), Size1=Vector3.new(0,0,dis),Size2=Vector3.new(1,1,dis),Boomerang=true,Transparency2=1,Material="Glass",Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(0.5, 0, 0),LifeTime=25}) end)

				else
					task.wait(.3)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local last = p.p
					local wawa=  Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
					local Points = PointLightning(p.p,hit.p, 25/3, 1)

					for i,v in ipairs(Points) do
						task.spawn(function()
							local Point, Distance = DrawPoint(last, v)
							last=v
							task.spawn(function()
							Module.Effect.TW({
								StartProps = {
									CFrame=p,
									Color=Color3.new(.5,0,0),
									Size=Vector3.new(.5,.5,0),
									Material="Glass"
								},
								TweenList = {
									{
										TweenInfo={1.5},
										TweenProperties={Transparency=0,Size=Vector3.new(.5,.5,Distance),CFrame=Point},
										Settings = {Yield=true}
									},
									{
										TweenInfo={i / #Points},
										TweenProperties={Transparency=1},
										Settings = {Yield=true}
									},
								},
							}) end)
							if i == #Points then
								task.wait(1.5)
								PlaySound("rbxassetid://3778610036", Point, mrandom(.7,.9), 4)
								for i = 1, math.random(4,6) do
									task.spawn(function() Module.Effect.new({StartCF=CFrame.new(Point.p, Point.p - Normal)*CFrame.new(mrandom(-3,3),mrandom(-1,1),mrandom(-3,3)),Size1=Vector3.new(),Size2=Vector3.new(3,5,3)*2,Transparency2=1,Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(1,1,1),Material="Glass",Shape="Ball",LifeTime=60,radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Boomerang=true}) end)
								end
							end
						end)
					end
				end
			end)
		end
		usingarmL = true
		lookmouse = false
		task.delay(.6,function()
			walkspeed=30
			cooldown = false
		end)
	elseif(io.KeyCode == Enum.KeyCode.Q)then
		if (Movement.Position.p-mouse.Hit.p).Magnitude>1000 then
			return
		end
		local mo = mouse.Hit * mouse.Hit.Rotation:Inverse()
		cooldown = true
		PlaySound("rbxassetid://6162449120",mo,mrandom(.8,1), 2)
		local pos = CFrame.new(mo.p+Vector3.new(0,1.5*2,0))*Movement.Position.Rotation
		Movement.Position = pos
		task.delay(.15,function()
			cooldown = false
		end)
		mo=mo+Vector3.new(0,1.5*2,0)
		task.spawn(function() Module.Effect.TW({
			StartProps = {
				CFrame=mo,
				Color=Color3.new(0, 1, 0),
				Size=Vector3.new(5,12,5)/3,
				Material = "Neon",
				Transparency=.7
			},
			TweenList = {
				{
					TweenInfo={1},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},
				{
					TweenInfo={.9},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},

				{
					TweenInfo={.6},
					TweenProperties={Size=Vector3.new(),Color=Color3.new(),CFrame=mo*CFrame.new(0,-3,0)*randomangle()},
					Settings = {Yield=true}
				},
			},
		}) end)
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0),Transparency1=.3, LifeTime=20, Size1=Vector3.new(),Size2=Vector3.new(20,1,20),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0), LifeTime=15,Transparency1=.3, Size1=Vector3.new(1,0,1),Size2=Vector3.new(1,30,1),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})
	end
end)


local dt = 0
local Sine = 0
game:GetService("RunService").Heartbeat:Connect(function(delta)
	dt = dt + delta
	if(plr.Character)then
		plr.Character:PivotTo(CFrame.new(9e9, 9e9, 9e9))
	end

	Sine = os.clock()*60
	
	if(Movement.Flying)then
		if math.random(9)==1 then
			Module.Effect.new({
				StartCF=Movement.Position*CFrame.new(0,-3,0)*radiananglefrom(3),
				Size1=Vector3.new(20,.5,20),
				Size2=Vector3.new(0,.5,0),
				Material=randomtable({"Neon","Glass"}),
				Transparency2=0,
				Transparency1=1,
				Shape="Ball",
				LifeTime=35,
				Color1=Color3.fromHSV(0.05, 1, math.random()),
				Color2=Color3.fromHSV(0.05, 1, math.random())
			})
		end
	end
	
	if(lookmouse)then
		Movement.Position = CFrame.lookAt(Movement.Position.Position, Vector3.new(mouse.Hit.X, Movement.Position.Y, mouse.Hit.Z))
	end
	
	local anim = {}
	if(not Movement.Walking and not Movement.Falling and not Movement.Jumping)then
		local tiltam = .04
		anim = {
			["Head"] = CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),
			Torso = CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),
			["Right Arm"] = CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0),
			["Left Arm"] = CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),
			["Left Leg"] = CFrame.new(),
			["Right Leg"] = CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0)
		}
	end

	if(Movement.Jumping)then
		anim = {
			["Head"] = CFrame.new(0,0,.1)*CFrame.Angles(math.rad(15),0,0),
			Torso = CFrame.new()*CFrame.Angles(math.rad(6),0,0),
			["Right Arm"] = CFrame.new(.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(80)),
			["Left Arm"] = CFrame.new(-.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(-80)),
			["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-15),math.rad(5),0),
			["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
		}
	elseif(Movement.Falling)then
		anim = {
			["Head"] = CFrame.new(0,0,-.1)*CFrame.Angles(math.rad(-25),0,0),
			Torso = CFrame.new()*CFrame.Angles(math.rad(-15),0,0),
			["Right Arm"] = CFrame.new(.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(125)),
			["Left Arm"] = CFrame.new(-.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(-125)),
			["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-35),math.rad(5),0),
			["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
		}
	end

	if(Movement.Walking and not Movement.Jumping and not Movement.Falling)then
		anim = {
			["Head"] = CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),
			Torso = CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),
			["Right Arm"] = CFrame.new(0,0,0-(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),
			["Left Arm"] = CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),
			["Left Leg"] = CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),
			["Right Leg"] = CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0)
		}
	end
	
	if(not usingarmL)then
		anim["Left Arm"] = nil
	end
	
	animate(anim)
	
	cframes["Torso"] = Movement.Position*offsets["Torso"]
	cframes["Head"] = cframes["Torso"]*offsets["Head"]
	cframes["Right Arm"] = cframes["Torso"]*offsets["Right Arm"]
	cframes["Right Leg"] = cframes["Torso"]*offsets["Right Leg"]
	cframes["Left Arm"] = cframes["Torso"]*offsets["Left Arm"]
	cframes["Left Leg"] = cframes["Torso"]*offsets["Left Leg"]
	
	for i, v in next, limbs do
		v.CFrame = cframes[i]
	end
	
	if(dt < 1/20)then
		return
	end
	dt = 0
	for i, v in next, {"Torso", "Left Arm", "Left Leg", "Head", "Right Arm", "Right Leg"} do
		task.spawn(createlimb, v)
	end

	local changes = {}
	for i, v in next, parts do
		table.insert(changes, {
			Part = replicatedparts[v] or v, Size = v.Size, CFrame = v.CFrame,
			Color = v.Color, Transparency = v.Transparency,
			Material = v.Material
		})
	end
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncColor', changes)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncMaterial', changes)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncResize', changes)
	task.spawn(function()
		if(#queueforremoval >= 6)then
			task.spawn(syncapi.InvokeServer, syncapi, 'Remove', table.clone(queueforremoval))
			for i, v in next, queueforremoval do
				v:Destroy()
			end
			table.clear(queueforremoval)
		end
	end)
end)