local plr = game:GetService("Players").LocalPlayer
local btools;
local syncapi;

print'waiting'

repeat task.wait() until plr.Backpack:FindFirstChild("ServerEndpoint", true) and plr.Backpack:FindFirstChild("ServerEndpoint", true):IsA("RemoteFunction")

print'got sync'

syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
btools = syncapi.Parent.Parent

game:GetService("RunService").Heartbeat:Connect(function()
	syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
	btools = syncapi.Parent.Parent
	btools.Parent = plr.Backpack
end)

local parts = {}

local Movement = {
	Position = CFrame.new(0, 5, 0),
	FakePosition = CFrame.new(0, 5, 0),
	MouseHit = CFrame.identity,
	Jumping = false,
	Falling = false,
	Walking = false,
	Flying = false,
}

local oldmainpos, walkspeed, gravityvelocity = Movement.Position, 30, 0
local w, a, s, d = false, false, false, false

local movementkeys = {
	w = function(up, io)
		w = not up
	end,
	a = function(up, io)
		a = not up
	end,
	s = function(up, io)
		s = not up
	end,
	d = function(up, io)
		d = not up
	end,
	f = function(up, io)
		if(not up)then
			Movement.Flying = not Movement.Flying
		end
	end,
	space = function(up, io)
		if(not up and not Movement.Falling and not Movement.Jumping and not Movement.Flying)then
			Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis/2)
			gravityvelocity = (1/60)*30
		end
	end,
}

local mouse = plr:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(false, io)
	end
end)

game:GetService("UserInputService").InputEnded:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(true, io)
	end
end)

local campart = Instance.new("Part")
campart.Size = Vector3.zero
campart.Transparency = 1
campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)

local muspart = Instance.new("Part")
muspart.Size = Vector3.zero
muspart.Transparency = 1
muspart.CFrame = Movement.Position

game:GetService("RunService").RenderStepped:Connect(function(dt)
	if(not campart) or (not pcall(function()
			campart.Parent = nil
			campart.CFrame = campart.CFrame
		end))then
		pcall(game.Destroy, campart)
		campart = Instance.new("Part")
		campart.Size = Vector3.zero
		campart.Transparency = 1
		campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)
	end
	if(not muspart or not pcall(function()
			muspart.Parent = game:GetService("JointsService")
			muspart.CFrame = muspart.CFrame
		end))then
		pcall(game.Destroy, muspart)
		muspart = Instance.new("Part")
		muspart.Size = Vector3.zero
		muspart.Transparency = 1
		muspart.CFrame = Movement.Position
		muspart.Parent = game:GetService("JointsService")
	end
	pcall(function()
		workspace.CurrentCamera.CameraSubject = campart
	end)
	muspart.CFrame = Movement.Position
	if(not muspart:FindFirstChildOfClass("Sound"))then
		local s = Instance.new("Sound", muspart)
		s.Volume = 1
		s.SoundId = "rbxasset://music/Invaders.mp3"
		s.Looped = true
		s.Playing = true
	end
end)

local realRotation = CFrame.identity
local momentum = 0
local momentummax = 40
local momentumspeed = 5
local walkingtime = os.clock()

local lastframe = os.clock()
local deltamult = 1

local function deltaclamp(val)
	return math.clamp(val*deltamult, 0, 1)
end

game:GetService("RunService").RenderStepped:Connect(function(delta)
	deltamult = 60*(os.clock() - lastframe)
	lastframe = os.clock()
	campart.CFrame = campart.CFrame:Lerp(Movement.Position*CFrame.new(0,1.5,0), deltaclamp(.3))

	oldmainpos = Movement.Position
	local shiftlock =  game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter

	if(not Movement.Flying)then
		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {workspace.Terrain}
		local ray = workspace:Raycast(Movement.Position.Position, Vector3.new(0,-3.1,0), param)
		if(ray)then
			Movement.Position = Movement.Position * CFrame.new(0,ray.Position.Y-Movement.Position.Y+3,0)
			gravityvelocity = 0
		else
			gravityvelocity = gravityvelocity - (((1/60)*1.4*(workspace.Gravity/196.2))*deltamult)
		end
	else
		gravityvelocity = 0
	end

	if(w or a or s or d)and(walkspeed>0)then
		Movement.Walking = true
	else
		Movement.Walking = false
		walkingtime = os.clock()
		momentum = 0
	end

	local fakewalkspeed = walkspeed

	if(Movement.Flying)then
		momentum = math.clamp((os.clock() - walkingtime) * momentumspeed, 0, momentummax)
	end
	fakewalkspeed = fakewalkspeed + momentum

	if(w and d)or(w and a)or(s and d)or(s and a)then
		fakewalkspeed = fakewalkspeed/1.4
	end

	local camlook = workspace.CurrentCamera.CFrame.LookVector

	if(Movement.Walking)and(not shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	elseif(shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	end

	if(w)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(a)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end
	if(s)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(d)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end

	if(not shiftlock)and(Movement.Position.X ~= oldmainpos.X)and(Movement.Position.Z ~= oldmainpos.Z)then
		Movement.Position = CFrame.new(Movement.Position.Position) * realRotation.Rotation

		if(Movement.Walking)and(not Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, 0, look.Z)), deltaclamp(math.pi/16))
		elseif(Movement.Walking)and(Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, look.Y, look.Z)), deltaclamp(math.pi/16))
		end

		realRotation = Movement.Position.Rotation
	end

	if(Movement.Position.Y < -200)then
		Movement.Position = CFrame.new(0,20,0)
		gravityvelocity = 0
	end

	Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis*gravityvelocity)

	if(not Movement.Flying)then
		if(oldmainpos.Y > Movement.Position.Y)then
			Movement.Falling = true
			Movement.Jumping = false
		elseif(oldmainpos.Y < Movement.Position.Y)then
			Movement.Falling = false
			Movement.Jumping = true
		else
			Movement.Falling = false
			Movement.Jumping = false
		end
	else
		Movement.Falling = false
		Movement.Jumping = false
	end
end)

local limbs = {}
local cframes = {}

local sizes = {
	["Torso"] = Vector3.new(2, 2, 1),
	["Right Arm"] = Vector3.new(1, 2, 1),
	["Left Arm"] = Vector3.new(1, 2, 1),
	["Right Leg"] = Vector3.new(1, 2, 1),
	["Left Leg"] = Vector3.new(1, 2, 1),
	["Head"] = Vector3.new(1, 1, 1),
	["Gun"] = Vector3.new(3.289, 1.935, 0.745),
	["Gun_FadeB"] = Vector3.new(0.5, 0.555, 0.555),
	["Gun_Crystal"] = Vector3.new(0.14, 0.186, 0.186)
}
local materials = {
	["Gun_Cyrstal"] = Enum.Material.Neon,
	["Gun_FadeB"] = Enum.Material.Neon,
}
local colors = {
	["Torso"] = Color3.fromRGB(255, 100, 53),
	["Gun_FadeB"] = Color3.fromRGB(255, 89, 89),
	["Gun_Crystal"] = Color3.fromRGB(4, 175, 236)
}
local reflectance = {
	["Torso"] = -.5,
	["Gun"] = .2
}
local meshes = {
	["Gun"] = "rbxassetid://6120339872",
	["Gun_FadeB"] = "rbxassetid://6120345442"
}
local meshscales = {
	["Gun"] = Vector3.new(.75, .75, .75),
	["Gun_FadeB"] = Vector3.new(.7,.7,.7)
}
local transparency = {
	["Gun"] = 1,
	["Gun_FadeB"] = 1.7,
	["Gun_Crystal"] = 1
}
local origtransparency = table.clone(transparency)

local offsets = {
	["Torso"] = CFrame.identity,
	["Left Leg"] = CFrame.new(-.5, -2, 0),
	["Right Leg"] = CFrame.new(.5, -2, 0),
	["Right Arm"] = CFrame.new(1.5, 0, 0),
	["Left Arm"] = CFrame.new(-1.5, 0, 0),
	["Head"] = CFrame.new(0, 1.5, 0),
	["Gun"] = CFrame.new(-0.0219726562, -1.76120234, -0.487823486, 6.258486e-07, -6.63396293e-07, -1, 0.999999881, -1.90734772e-06, 6.25849793e-07, -1.90734841e-06, -1, 6.63395099e-07),
	["Gun_Crystal"] = CFrame.new(-1.57798314, 0.910415649, 0, 1, -1.8491927e-06, 5.25676569e-09, 1.30385047e-06, 0.707101941, 0.707111657, -1.31130253e-06, -0.707111657, 0.707101941),
	["Gun_FadeB"] = CFrame.new(-1.30953908, 0.663314819, 0, 1, -1.30384865e-06, 1.31130457e-06, 1.30385047e-06, 1, -1.445777e-06, -1.31130253e-06, 1.44577859e-06, 1),
}
local origoffsets = table.clone(offsets)
local replicatedparts = {}

function checkregion(where, range)
	local params = OverlapParams.new()
	params.FilterDescendantsInstances = parts
	params.RespectCanCollide = false
	params.FilterType = Enum.RaycastFilterType.Exclude
	local da = {}
	for i,v in ipairs(workspace:GetPartBoundsInRadius(where, range, params)) do
		if(v.Name ~= "Baseplate" and v.Parent ~= workspace.Terrain and v.Size.X < 400)then
			table.insert(da,v)
		end
	end
	return da
end

local function kill(object)
	if(table.find(parts, object))then return end
	local parent = object.Parent
	syncapi:InvokeServer('Remove', {object})
	return object.Parent ~= parent
end

local function destroy(obj)
	local orig = obj

	if(replicatedparts[obj])then obj = replicatedparts[obj] end
	replicatedparts[orig] = nil

	orig:Destroy()

	table.remove(parts, table.find(parts, orig))
	syncapi:InvokeServer('Remove', {obj})
end

local function newpart()
	local p = syncapi:InvokeServer('CreatePart', 'Normal', CFrame.new(9e9, 9e9, 9e9), workspace.Terrain)
	p.Parent = game:GetService("ReplicatedStorage")
	p.Anchored = true

	local fakepart = Instance.new("Part")
	fakepart.CFrame = CFrame.new(9e9, 9e9, 9e9)
	fakepart.Anchored = true
	fakepart.TopSurface = Enum.SurfaceType.Smooth;
	fakepart.BottomSurface = Enum.SurfaceType.Smooth;
	table.insert(parts, fakepart)
	replicatedparts[fakepart] = p
	fakepart.Parent = workspace.Terrain

	return fakepart
end

local function createlimb(name)
	local limb = newpart()
	limbs[name] = limb

	limb.Material = materials[name] or Enum.Material.Glass
	limb.Transparency = 0
	limb.Anchored = true
	limb.Color = colors[name] or Color3.fromRGB(231, 231, 236)
	limb.Size = sizes[name] or Vector3.zero
	limb.CFrame = cframes[name] or CFrame.identity
	limb.Reflectance = reflectance[name] or 0
	limb.Transparency = transparency[name] or 0

	if(meshes[name])then
		task.spawn(function()
			local mesh = syncapi:InvokeServer('CreateMeshes', {{
				Part = replicatedparts[limb]
			}})[1]
			mesh.MeshType = Enum.MeshType.FileMesh
			mesh.MeshId = meshes[name]
			mesh.Scale = meshscales[name] or Vector3.one
		end)

		local mesh = Instance.new("SpecialMesh", limb)
		mesh.MeshType = Enum.MeshType.FileMesh
		mesh.MeshId = meshes[name]
		mesh.Scale = meshscales[name] or Vector3.one
	end

	repeat task.wait() until limbs[name] ~= limb
	destroy(limb)
end

local function PlaySound(a, b, c, d, e)
	local temp = Instance.new("Attachment")
	temp.Name = ""

	temp.CFrame = b
	local audio = Instance.new("Sound", temp)
	audio.Name = ""
	audio.PlayOnRemove = true
	audio.Pitch = c
	audio.SoundId = a
	audio.Volume = d
	temp.Parent = workspace.Terrain
	if e then
		audio.TimePosition = e
	end
	temp:Destroy()
end

local LightningBolt = {}
local ActiveEffects = {}
local Module = {
	Effect = {}
}
local tospin = {}
function Lerp3D(a, b, c, DeltaTime)
	return a:Lerp(b, 1 - c ^ DeltaTime)
end
function LerpNum(a, b, c, DeltaTime)
	return a + (b - a) * (1 - c ^ DeltaTime)
end
function tween(a,info, props)
	local re = game:GetService("TweenService"):Create(a, TweenInfo.new(table.unpack(info)), props)
	re:Play()
	return re
end
--effect2(StartProperties:{}, TweenList:{TweenInfo:{}, TweenProperties{}, TweenSettings:{Yield}})
function Module.Effect.TW(tbl)
	task.spawn(function()
		local dprops = tbl.StartProps
		local list = tbl.TweenList
		local new = newpart()
		new.Size = dprops.Size or Vector3.new()
		new.Material=dprops.Neon or "Neon"
		for prop in pairs(dprops) do
			new[prop]=dprops[prop]
		end
		new.Parent=workspace
		if tbl.Spin  then
			tospin[new] = tbl.Spin
		end
		for index, info in ipairs(list) do
			local Settings =	info.Settings or {}
			if Settings.Spin then
				tospin[new] = Settings.Spin
			end
			local tw = tween(new, info.TweenInfo, info.TweenProperties)
			if Settings.MulSpin then
				for i = 1, Settings.MulSpin do
					tospin[new] = tbl.Spin * tbl.Spin
				end
			end
			if Settings.Yield then
				tw.Completed:Wait()
			end
			if index==#list or new == nil or new.Parent~=workspace then
				destroy(new)
				break
			end
		end end)
end
function Module.Effect.colorshift3(tbl)
	task.spawn(function() local a = newpart()
		a.CFrame=tbl.CF
		a.Size=tbl.Size
		a.Color=tbl.C1
		a.Material="Neon"
		game:GetService("Debris"):AddItem(a, tbl.time)
		tween(a, {tbl.time}, {Transparency=1})
		tween(a, {tbl.time/2}, {Color=tbl.C2}).Completed:Wait()
		tween(a, {tbl.time/2}, {Color=tbl.C3}) end)
end
function Module.Effect.new(tbl)	
	task.spawn(function() tbl.Color1 = tbl.Color1 or Color3.new()
		tbl.Color2 = tbl.Color2 or Color3.new()
		tbl.Size1=tbl.Size1 Vector3.new(5,5,5)
		tbl.Size2=tbl.Size2 or Vector3.new(5,5,5)
		tbl.StartCF=tbl.StartCF or CFrame.new()
		tbl.LifeTime=(tbl.LifeTime or 100)
		tbl.Shape=tbl.Shape or "Part"
		tbl.sbm = tbl.sbm or 1
		tbl.mbm = tbl.mbm or 1
		tbl.b1 = 1+tbl.mbm/50
		tbl.b2 = 1+tbl.sbm/50
		tbl.radX = tbl.radX or 0
		tbl.radY = tbl.radY or 0
		tbl.radZ = tbl.radZ or 0
		tbl.Size2=tbl.Size2 or Vector3.new()
		tbl.Transparency1=tbl.Transparency1 or 0
		tbl.Transparency2=tbl.Transparency2 or 0
		local Part = newpart()
		Part.CanCollide = false
		Part.CanTouch = false
		Part.CanQuery = false
		Part.Anchored = true
		Part.Name = ""
		Part.CFrame = tbl.StartCF or CFrame.new()
		Part.Size = tbl.DSize or tbl.Size1 or Vector3.new()
		Part.Transparency = tbl.Transparency1  or 0
		Part.Color =  tbl.DColor  or tbl.Color1 or Color3.new()
		Part.Material = tbl.DMaterial  or tbl.Material  or Enum.Material.Neon
		Part.Reflectance = tbl.Reflectance or 0
		if tbl.MoveTo then
			if tbl.Boomerang then
				tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime*tbl.b1
			else
				tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime
			end
		end
		if tbl.Boomerang then
			tbl.EndSize=(tbl.Size1 - tbl.Size2)*tbl.b2
		else
			tbl.EndSize=(tbl.Size1 - tbl.Size2)
		end
		tbl.EndTransparency=tbl.Transparency1-tbl.Transparency2
		table.insert(ActiveEffects, {
			["Part"] = Part,
			[2] = tbl,
			Index = 1
		}) end)
end

local LightningBolt = {}

function Module.Effect.clear()
	for data in pairs(ActiveEffects) do
		destroy(data.Part)
	end
	table.clear(ActiveEffects)
end
function Module.Effect.Lightning(Table)
	assert(Table.Start, "Start is nil")
	assert(Table.End, "Start is nil")
	Table.Curve = Table.Curve or 0
	Table.Radius = Table.Radius or 0
	Table.LifeTime = Table.LifeTime or 1
	local A1, A2 = {}, {}
	A1.WorldPosition, A1.WorldAxis = Table.Start.p, Vector3.new()
	A2.WorldPosition, A2.WorldAxis = Table.End.p, Vector3.new()
	local self = LightningBolt.new(A1, A2, Table.Segments or 10, workspace.Terrain)
	self.Enabled = true 
	self.Attachment0, self.Attachment1 = A1, A2
	if Table.ProperCurve then
		self.CurveSize0, self.CurveSize1 = Table.Curve1 or 0,Table.Curve2 or 0
	else
		self.CurveSize0, self.CurveSize1 = -Table.Curve or 0,Table.Curve or 0
	end
	self.MinRadius, self.MaxRadius = -Table.Radius or 0, Table.Radius or 0
	self.Frequency = Table.Frequency or 1
	self.AnimationSpeed = Table.AnimationSpeed or 0
	self.Thickness = Table.Thickness or 1
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = Table.MinThickness or 1, Table.MaxThickness or 1
	self.MinTransparency, self.MaxTransparency = 0, 1
	self.PulseSpeed = Table.LifeTime or 1
	self.PulseLength = Table.LifeTime or 1
	self.FadeLength = Table.LifeTime*2 or 2
	self.ContractFrom = Table.LifeTime*20 or 20
	self.Color = Table.Color or Color3.new()
end


local Throttle = 0
local ConsecutiveFrames = 0
game:GetService("RunService").Heartbeat:Connect(function(DeltaTime)

	ConsecutiveFrames = ConsecutiveFrames + DeltaTime
	Throttle = 0
	for _ = 1,ConsecutiveFrames/(1/60) do
		ConsecutiveFrames = ConsecutiveFrames - (1/60)
		Throttle = Throttle + 1
	end
	for tt = 1, Throttle do
		for i in pairs(tospin) do
			i.CFrame=i.CFrame*tospin[i]
			if not i:IsDescendantOf(game) then
				tospin[i]=nil
			end
		end
	end
	for throttleindex = 1, Throttle do
		for i, Data in pairs(ActiveEffects) do
			local p=Data.Part
			local tbl = Data[2]
			local acttime = tbl.LifeTime
			if tbl.Boomerang then
				p.Size=p.Size-(Vector3.new((tbl.EndSize.X)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Y)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Z)*((1 - (Data.Index/acttime)*tbl.b2)))*tbl.b2)/acttime
				p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
				if tbl.Color2 then
					p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
				end
				if tbl.MoveTo ~= nil then
					local a = p.Orientation
					p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-(tbl.MovingSpeed)*((1-(Data.Index/acttime)*tbl.b1)))
					p.Orientation = a
				end
			else
				p.Size=p.Size-tbl.EndSize/acttime/2
				p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
				if tbl.Color2 then
					p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
				end
				if tbl.MoveTo ~= nil then
					local a = p.Orientation
					p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-tbl.MovingSpeed/2)
					p.Orientation = a
				end
			end
			if Data.Index >= (acttime * 2)+1 then
				table.remove(ActiveEffects, i)
				destroy(p)
			end
			Data.Index=Data.Index+1
		end
	end
end)



local clock = os.clock


function DiscretePulse(input, s, k, f, t, min, max) --input should be between 0 and 1. See https://www.desmos.com/calculator/hg5h4fpfim for demonstration.
	return math.clamp( (k)/(2*f) - math.abs( (input - t*s + 0.5*(k)) / (f) ), min, max )
end

function NoiseBetween(x, y, z, min, max)
	return min + (max - min)*(math.noise(x, y, z) + 0.5)
end

function CubicBezier(p0, p1, p2, p3, t)
	return p0*(1 - t)^3 + p1*3*t*(1 - t)^2 + p2*3*(1 - t)*t^2 + p3*t^3
end
local rng = Random.new()
local xInverse = CFrame.lookAt(Vector3.new(), Vector3.new(1, 0, 0)):inverse()

local ActiveBranches = {}

LightningBolt.__index = LightningBolt

--Small tip: You don't need to use actual Roblox Attachments below. You can also create "fake" ones as follows:

function LightningBolt.new(Attachment0, Attachment1, PartCount,parent)
	local self = setmetatable({}, LightningBolt)

	--Main (default) Properties--

	--Bolt Appearance Properties--
	self.Enabled = true --Hides bolt without destroying any parts when false
	self.Attachment0, self.Attachment1 = Attachment0, Attachment1 --Bolt originates from Attachment0 and ends at Attachment1
	self.CurveSize0, self.CurveSize1 = 0, 0 --Works similarly to beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png
	self.MinRadius, self.MaxRadius = 0, 2.4 --Governs the amplitude of fluctuations throughout the bolt
	self.Frequency = 1 --Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning
	self.AnimationSpeed = 7 --Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)
	self.Thickness = 1 --The thickness of the bolt
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = 0.2, 1 --Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt

	--Bolt Kinetic Properties--
	--Allows for fading in (or out) of the bolt with time. Can also create a "projectile" bolt
	--Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)
	--Works by passing a "wave" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)
	--See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties
	self.MinTransparency, self.MaxTransparency = 0, 1 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseSpeed = 2 --Bolt arrives at Attachment1 1/PulseSpeed seconds later. See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseLength = 1000000 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.FadeLength = 0.2 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.ContractFrom = 0.5 --Parts shorten or gro
	self.Color = Color3.new(1, 1, 1) --Can bw once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441

	--Bolt Color Properties--e a Color3 or ColorSequence
	self.ColorOffsetSpeed = 3 --Sets speed at which ColorSequence travels along Bolt

	--

	self.Parts = {} --The BoltParts which make up the Bolt


	local a0, a1 = Attachment0, Attachment1
	local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*self.CurveSize0, a1.WorldPosition - a1.WorldAxis*self.CurveSize1, a1.WorldPosition
	local PrevPoint, bezier0 = p0, p0
	local MainBranchN = PartCount or 30

	for i = 1, MainBranchN do
		local t1 = i/MainBranchN
		local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
		local NextPoint = i ~= MainBranchN and (CFrame.lookAt(bezier0, bezier1)).Position or bezier1
		local BPart = newpart()
		BPart.Anchored = true
		BPart.Color = Color3.new(1, 1, 1)
		BPart.CanTouch, BPart.CanQuery = false, false
		BPart.Material = Enum.Material.Neon
		BPart.Transparency = 1
		BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, 0, 0)
		BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
		BPart.Parent = parent
		BPart.Locked, BPart.CastShadow = true, false
		self.Parts[i] = BPart
		PrevPoint, bezier0 = NextPoint, bezier1
	end

	self.PartsHidden = false
	self.DisabledTransparency = 1
	self.StartT = clock()
	self.RanNum = math.random()*100
	self.RefIndex = #ActiveBranches + 1

	ActiveBranches[self.RefIndex] = self

	return self
end

function LightningBolt:Destroy()
	ActiveBranches[self.RefIndex] = nil

	for i = 1, #self.Parts do
		destroy(self.Parts[i])
		task.spawn(function()
			task.wait()
			table.remove(self.Parts, i)
		end)
		if i%100 == 0 then wait() end
	end
	task.spawn(function()
		repeat task.wait() until #self.Parts == 0
		table.clear(self)
		self = nil
	end)
end

local offsetAngle = math.cos(math.rad(90))

game:GetService("RunService").Heartbeat:Connect(function ()

	for _, ThisBranch in pairs(ActiveBranches) do
		if ThisBranch.Enabled == true then
			ThisBranch.PartsHidden = false
			local MinOpa, MaxOpa = 1 - ThisBranch.MaxTransparency, 1 - ThisBranch.MinTransparency
			local MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius
			local thickness = ThisBranch.Thickness
			local Parts = ThisBranch.Parts
			local PartsN = #Parts
			local RanNum = ThisBranch.RanNum
			local StartT = ThisBranch.StartT
			local spd = ThisBranch.AnimationSpeed
			local freq = ThisBranch.Frequency
			local MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier
			local a0, a1, CurveSize0, CurveSize1 = ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1
			local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*CurveSize0, a1.WorldPosition - a1.WorldAxis*CurveSize1, a1.WorldPosition
			local timePassed = clock() - StartT
			local PulseLength, PulseSpeed, FadeLength = ThisBranch.PulseLength, ThisBranch.PulseSpeed, ThisBranch.FadeLength
			local Color = ThisBranch.Color
			local ColorOffsetSpeed = ThisBranch.ColorOffsetSpeed
			local contractf = 1 - ThisBranch.ContractFrom
			local PrevPoint, bezier0 = p0, p0

			if timePassed < (PulseLength + 1) / PulseSpeed then

				for i = 1, PartsN do
					--local spd = NoiseBetween(i/PartsN, 1.5, 0.1*i/PartsN, -MinAnimationSpeed, MaxAnimationSpeed) --Can enable to have an alternative animation which doesn't shift the noisy lightning "Texture" along the bolt
					local BPart = Parts[i]
					local t1 = i/PartsN
					local Opacity = DiscretePulse(t1, PulseSpeed, PulseLength, FadeLength, timePassed, MinOpa, MaxOpa)
					local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
					local time = -timePassed --minus to ensure bolt waves travel from a0 to a1
					local input, input2 = (spd*time) + freq*10*t1 - 0.2 + RanNum*4, 5*((spd*0.01*time) / 10 + freq*t1) + RanNum*4
					local noise0 = NoiseBetween(5*input, 1.5, 5*0.2*input2, 0, 0.1*2*math.pi) + NoiseBetween(0.5*input, 1.5, 0.5*0.2*input2, 0, 0.9*2*math.pi)
					local noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)*math.exp(-5000*(t1 - 0.5)^10)
					local thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)
					local NextPoint = i ~= PartsN and (CFrame.new(bezier0, bezier1)*CFrame.Angles(0, 0, noise0)*CFrame.Angles(math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)), 0, 0)*CFrame.new(0, 0, -noise1)).Position or bezier1

					if Opacity > contractf then
						BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					elseif Opacity > contractf - 1/(PartsN*FadeLength) then
						local interp = (1 - (Opacity - (contractf - 1/(PartsN*FadeLength)))*PartsN*FadeLength)*(t1 < timePassed*PulseSpeed - 0.5*PulseLength and 1 or -1)
						BPart.Size = Vector3.new((1 - math.abs(interp))*(NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(PrevPoint + (NextPoint - PrevPoint)*(math.max(0, interp) + 0.5*(1 - math.abs(interp))), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					else
						BPart.Transparency = 1
					end

					if typeof(Color) == "Color3" then
						BPart.Color = Color
					else --ColorSequence
						t1 = (RanNum + t1 - timePassed*ColorOffsetSpeed)%1
						local keypoints = Color.Keypoints 
						for i = 1, #keypoints - 1 do --convert colorsequence onto lightning
							if keypoints[i].Time < t1 and t1 < keypoints[i+1].Time then
								BPart.Color = keypoints[i].Value:lerp(keypoints[i+1].Value, (t1 - keypoints[i].Time)/(keypoints[i+1].Time - keypoints[i].Time))
								break
							end
						end
					end

					PrevPoint, bezier0 = NextPoint, bezier1
				end

			else

				ThisBranch:Destroy()

			end

		else --Enabled = false

			if ThisBranch.PartsHidden == false then
				ThisBranch.PartsHidden = true
				local datr = ThisBranch.DisabledTransparency
				for i = 1, #ThisBranch.Parts do
					ThisBranch.Parts[i].Transparency = datr
				end
			end

		end
	end

end)

local function animate(cfs, cf, alpha)
	if(typeof(cfs) == "table")then
		for i, v in next, cfs do
			offsets[i] = offsets[i]:Lerp(origoffsets[i] * v, .1)
		end
	else
		offsets[cfs] = offsets[cfs]:Lerp(origoffsets[cfs] * cf, alpha)
	end
end

function radiananglefrom(range)
	return CFrame.Angles(math.rad(math.random(-range,range)),math.rad(math.random(-range,range)),math.rad(math.random(-range,range)))
end

function randomtable(t)
	return t[math.random(#t)]
end

function randomangle()
	return CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360))
end

function mrandom(a,b)
	return Random.new():NextNumber(a or -1,b or 1)
end

function cfoffset(range)
	return CFrame.new((mrandom(-range,range)),mrandom(-range,range),mrandom(-range,range))
end

function DrawPoint(A,B)
	local Distance = (A-B).Magnitude
	return CFrame.new(A, B)*CFrame.new(0,0,-Distance/2), Distance
end
function PointLightning(Start, End, Segments, Offset)
	local Points = {}
	for i = 0, Segments do
		local Offset = Vector3.new(mrandom(-Offset,Offset),mrandom(-Offset,Offset),mrandom(-Offset,Offset))
		if i == 0 or i == Segments then
			Offset = Vector3.new()
		end
		table.insert(Points, 
			Start + (End - Start).Unit * i * (End - Start).Magnitude/Segments + Offset
		)
	end
	return Points, Offset
end


local Bezier = (function()
	-- Bezier
	-- Crazyman32
	-- April 1, 2015

	-- Modified January 28, 2016
	-- Optimized for Quadratic and Cubic cases
	-- Clarified documentation for GetPath()

	-- Modified December 5, 2017
	-- Added method 'GetLength()'
	-- Added method 'GetPathBySegmentLength()'
	-- Added method 'GetPathByNumberSegments()'

--[[

METHODS:

	b = Bezier.new(thisModule)
	
	Vector3          b:Get(ratio)
	Array<Vector3>   b:GetPath(step)
	Array<Vector3>   b:GetPathBySegmentLength(segmentLength)
	Array<Vector3>   b:GetPathByNumberSegments(numSegments)
	Number           b:GetLength([step])
	Array<Vector3>   b:GetPoints()

-------------------------------------------------------------------------------------------


EXAMPLES AND DOCUMENTATION:

-------------------------------------------------------------------------------------------

local Bezier = require(thisModule)

local b = Bezier.new(Vector3 pointA, Vector3 pointB, Vector3 pointC, ...)
	> Create a new bezier object
	> Must input at least 3 Vector3 points, or else it will throw an error
	
	> TIP: Do not create multiple objects with the same order and set of
	       points. Doing so would be pointless. Reuse the object when you can.
	
	> If 3 points are given, the module is optimized automatically for the quadratic case
	> If 4 points are given, the module is optimized automatically for the cubic case

-------------------------------------------------------------------------------------------

b:Get(ratio)
	> Get a Vector3 position on the curve with the given ratio
	> Ratio should be between 0 and 1
		> 0 = Starting point
		> 1 = Ending point
		> 0.5 = 50% along the path
		> 0.2 = 20% along the path
		> etc.

local positionStart = b:Get(0)
local positionMid   = b:Get(0.5)
local positionEnd   = b:Get(1)

-------------------------------------------------------------------------------------------

b:GetPathBySegmentLength(segmentLength)
	> Create a path along the curve, where the segments are roughly 'segmentLength' long
	> Returns a table of Vector3 positions

-------------------------------------------------------------------------------------------

b:GetPathByNumberSegments(numSegments)
	> Creates a path along the curve with 'numSegment' segments
	> Returns a table of Vector3 positions

-------------------------------------------------------------------------------------------

b:GetPath(step)
	> Create path along curve (returns table of Vector3 positions)
	> 'step' is the ratio step and should be within the range of (0, 1)

local path1 = b:GetPath(0.1) -- Higher resolution path
local path2 = b:GetPath(0.5) -- Lower resolution path

-------------------------------------------------------------------------------------------

b:GetLength([step])
	> Returns the length of a given path based on the step
	> 'step' is the ratio step and should be within the range of (0, 1). It defaults to 0.1
	> This is the same as calling 'b:GetPath(step)' and then summing up the distances
	  between each point. It is a rough approximation.

local length = b:GetLength()

-------------------------------------------------------------------------------------------

b:GetPoints()
	> Get the original control points that were inputted when object was created
	> Returns a table of Vector3 points

--]]





	-- NOTE: This was designed for higher-order bezier curves. However,
	--	has been optimized for quadratic and cubic cases. Curves of
	--	any degree can be calculated, but are not optimized above the
	--	cubic case.

	-- More info on Bezier Curves:
	-- http://en.wikipedia.org/wiki/Bezier_curve
	-- http://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm

	-- I recommend reading the Properties section for the first Wiki link


	-- This Bezier module was originally designed for my Bezier Path Plugin:
	-- http://www.roblox.com/item.aspx?id=232918839



	local Bezier = {}
	Bezier.__index = Bezier


	function Bezier.new(...)

		local points = {...}
		assert(#points >= 3, "Must have at least 3 points")

		local isQuadratic = (#points == 3)
		local isCubic = (#points == 4)

		local bezier = {}

		local V3 = Vector3.new
		local lerpV3 = V3().lerp

		local length = nil

		local lines = {}
		local numLines = 0
		local finalLine = nil
		-- Line index key:
		-- [1] = First point
		-- [2] = Second point
		-- [3] = Current Midpoint


		-- Create mutable pseudo-Vector3 points:
		local function CreatePoint(v3)
			--local point = {X = v3.X; Y = v3.Y; Z = v3.Z}
			local point = {v3.X, v3.Y, v3.Z}
			function point:ToVector3()
				return V3(self[1], self[2], self[3])
			end
			function point:lerp(other, ratio)
				return lerpV3(self:ToVector3(), other:ToVector3(), ratio)
			end
			return point
		end


		-- Initialize lines:
		if (not isQuadratic and not isCubic) then

			-- Initialize first lines:
			for i = 1,#points-1 do
				local p1 = CreatePoint(points[i])
				local p2 = CreatePoint(points[i + 1])
				local line = {p1, p2, CreatePoint(p1)}
				lines[#lines + 1] = line
			end

			local relativeLines = lines

			-- Initialize rest of lines:
			for n = #lines,2,-1 do
				local newLines = {}
				for i = 1,n-1 do
					local l1, l2 = relativeLines[i], relativeLines[i + 1]
					local line = {l1[3], l2[3], CreatePoint(l1[3])}
					newLines[i] = line
					lines[#lines + 1] = line
				end
				relativeLines = newLines
			end

			finalLine = relativeLines[1]

			numLines = #lines

		end


		-- Get a point on the curve with the given ratio:
		if (isQuadratic) then

			local p0, p1, p2 = points[1], points[2], points[3]

			-- Quadratic solution:
			function bezier:Get(r, clampRatio)
				if (clampRatio) then
					r = (r < 0 and 0 or r > 1 and 1 or r)
				end
				return (1-r)*(1-r)*p0+2*(1-r)*r*p1+r*r*p2
			end

		elseif (isCubic) then

			local p0, p1, p2, p3 = points[1], points[2], points[3], points[4]

			-- Cubic solution:
			function bezier:Get(r, clampRatio)
				if (clampRatio) then
					r = (r < 0 and 0 or r > 1 and 1 or r)
				end
				return (1-r)*(1-r)*(1-r)*p0+3*(1-r)*(1-r)*r*p1+3*(1-r)*r*r*p2+r*r*r*p3
			end

		else

			function bezier:Get(ratio, clampRatio)
				if (clampRatio) then
					ratio = (ratio < 0 and 0 or ratio > 1 and 1 or ratio)
				end
				-- Any degree solution:
				for i = 1,numLines do
					local line = lines[i]
					local mid = line[1]:lerp(line[2], ratio)
					local pt = line[3]
					pt[1], pt[2], pt[3] = mid.X, mid.Y, mid.Z
				end
				return finalLine[3]:ToVector3()
			end

		end


		-- Approximated length:
		function bezier:GetLength(step)
			if (not length) then
				local path = self:GetPath(step or 0.1)
				local l = 0
				for i = 2,#path do
					local dist = (path[i - 1] - path[i]).Magnitude
					l = (l + dist)
				end
				length = l
			end
			return length
		end


		-- Get a path of the curve with the given step:
		-- Returns a table of Vector3 points
		function bezier:GetPath(step)
			assert(type(step) == "number", "Must provide a step increment")
			-- Check step domain is within interval (0.0, 1.0):
			assert(step > 0 and step < 1, "Step out of domain; should be between 0 and 1 (exclusive)")
			local path = {}
			local lastI = 0
			for i = 0,1,step do
				lastI = i
				path[#path + 1] = self:Get(i)
			end
			-- In case 'step' didn't fill path fully, properly handle last remaining point:
			if (lastI < 1) then
				local overrideLast = ((1 - lastI) < (step * 0.5))
				path[#path + (overrideLast and 0 or 1)] = self:Get(1)
			end
			return path
		end


		function bezier:GetPathByNumberSegments(numSegments)
			assert(type(numSegments) == "number", "Must provide number of segments")
			assert(numSegments > 0, "Number of segments must be greater than 0")
			return self:GetPath(1 / numSegments)
		end


		function bezier:GetPathBySegmentLength(segmentLength)
			assert(type(segmentLength) == "number", "Must provide a segment length")
			assert(segmentLength > 0, "Segment length must be greater than 0")
			local length = self:GetLength()
			local numSegments = length / segmentLength
			return self:GetPathByNumberSegments(math.floor(numSegments + 0.5))
		end


		-- Get the control points (the original Vector3 arguments passed to create the object)
		function bezier:GetPoints()
			return points
		end


		return setmetatable(bezier, Bezier)

	end



	return Bezier
end)()

local cooldown = false

local usingarmR = true
local usingarmL = true
local usingtorso = true
local disableanim = false

local lookmouse = false
local switching = false
local cangun = false
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe or cooldown)then return end
	if(io.KeyCode == Enum.KeyCode.E)then
		if Movement.Falling then
			return
		end
		walkspeed=0
		cooldown = true
		lookmouse = true
		usingarmL = false
		local c;c=game:GetService("RunService").Heartbeat:Connect(function()
			animate({
				["Left Arm"] = CFrame.new(0,1.1,-.5)*CFrame.Angles(math.rad(120),0,0)
			})
		end)
		task.wait(.6)
		c:Disconnect()
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = parts
		local allc = math.random(20,30)
		for i = 1, allc do
			local hit = mouse.Hit
			task.wait(.02)
			task.spawn(function()
				local dest = (Movement.Position*cfoffset(.7)).p
				task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest)*randomangle(),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(1,1,5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=15,radX=mrandom(-12,12),radY=mrandom(-12,12),radZ=mrandom(-12,12)}) end)
				local p = Movement.Position*CFrame.new(mrandom(-4,4),mrandom(8,15),mrandom(-4,4))
				local spread = Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
				local dir = (CFrame.new(p.p,hit.p).LookVector.Unit*1000 + spread*70)
				local hitray = workspace:Raycast(p.p, dir, params)
				local hit = hit
				local Normal = Vector3.new(0,1,0)
				if hitray then
					hit=CFrame.new(hitray.Position)
					Normal = hitray.Normal
				else
					hit = CFrame.new(p.p + dir)
				end
				local a = newpart()
				a.CFrame = CFrame.new(p.p, Movement.Position.p)
				a.Size=Vector3.new()
				a.Material="Glass"
				a.Color=Color3.new(1, 0.3, 0)
				a.Anchored=true
				a.CastShadow=false
				a.CastShadow=false
				a.CanQuery=false
				a.CanCollide=false
				task.spawn(function()
					local last = p.p
					local Points = PointLightning(p.p,Movement.Position.p, 8/3, .5)

					for i,v in ipairs(Points) do
						local Point, Distance = DrawPoint(last, v)
						task.spawn(function()
							Module.Effect.TW({
								StartProps = {
									CFrame=Point,
									Color=Color3.new(1,.15,0),
									Size=Vector3.new(),
									Material = "Glass"
								},
								TweenList = {
									{
										TweenInfo={.5},
										TweenProperties={Size=Vector3.new(.5,.5,Distance)},
										Settings = {Yield=true}
									},
									{
										TweenInfo={.5,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
										TweenProperties={Transparency=1,Size=Vector3.new(0,0,Distance)},
										Settings = {Yield=true}
									},
								},
							}) end)
						last=v
						if i == #Points  then
							task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(2.5,2.5,2.5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=35}) end)
						end
						PlaySound("rbxassetid://4307214211", Point, mrandom(.8,1.2), .2)
						task.wait(.05)
					end
				end)

				tween(a, {.5}, {Size=Vector3.new(.5,.5,2)}).Completed:Wait()
				tween(a, {.5}, {CFrame=CFrame.new(p.p, hit.p)}).Completed:Wait()
				p = CFrame.new(p.p, hit.p)
				local dis = (p.p - hit.p).Magnitude



				if math.random(2)==1 then
					task.wait(.3)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)

					task.spawn(function() Module.Effect.new({StartCF=CFrame.new(p.p, hit.p) * CFrame.new(0,0,-dis/2), Size1=Vector3.new(0,0,dis),Size2=Vector3.new(1,1,dis),Boomerang=true,Transparency2=1,Material="Glass",Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(0.5, 0, 0),LifeTime=25}) end)

				else
					task.wait(.3)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local last = p.p
					local wawa=  Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
					local Points = PointLightning(p.p,hit.p, 25/3, 1)

					for i,v in ipairs(Points) do
						task.spawn(function()
							local Point, Distance = DrawPoint(last, v)
							last=v
							task.spawn(function()
								Module.Effect.TW({
									StartProps = {
										CFrame=p,
										Color=Color3.new(.5,0,0),
										Size=Vector3.new(.5,.5,0),
										Material="Glass"
									},
									TweenList = {
										{
											TweenInfo={1.5},
											TweenProperties={Transparency=0,Size=Vector3.new(.5,.5,Distance),CFrame=Point},
											Settings = {Yield=true}
										},
										{
											TweenInfo={i / #Points},
											TweenProperties={Transparency=1},
											Settings = {Yield=true}
										},
									},
								}) end)
							if i == #Points then
								task.wait(1.5)
								PlaySound("rbxassetid://3778610036", Point, mrandom(.7,.9), 4)
								for i = 1, math.random(4,6) do
									task.spawn(function() Module.Effect.new({StartCF=CFrame.new(Point.p, Point.p - Normal)*CFrame.new(mrandom(-3,3),mrandom(-1,1),mrandom(-3,3)),Size1=Vector3.new(),Size2=Vector3.new(3,5,3)*2,Transparency2=1,Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(1,1,1),Material="Glass",Shape="Ball",LifeTime=60,radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Boomerang=true}) end)
								end

								for i,v in ipairs(checkregion(hit.p, 5)) do
									task.spawn(function()
										if(not kill(v))then return end
										task.spawn(function()
											local a = newpart()
											a.CanCollide=  false
											a.CanQuery = false
											a.Anchored=  true
											a.CastShadow=false
											a.CFrame=v.CFrame 
											a.Color=Color3.new(0.5,0,0)
											a.Size=v.Size
											a.Material="Glass"
											tween(a, {1}, {CFrame=v.CFrame*CFrame.new(0,mrandom(5,8),0),Transparency=1}).Completed:Wait()
											destroy(a)
										end)


										Module.Effect.TW({
											Shape = randomtable({"Ball", "Part"}),
											StartProps = {
												CFrame=v.CFrame*randomangle(),
												Color=Color3.new(1,.15,0),
												Size=Vector3.new(.4,4,.4),
											},
											TweenList = {
												{
													TweenInfo={3},
													TweenProperties={Transparency=1,Color=Color3.new()},
												},
												{
													TweenInfo={2},
													TweenProperties={Position=v.Position+cfoffset(8).p},
													Settings = {Yield=true,Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))}

												},
												{
													TweenInfo={2,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
													TweenProperties={Position=v.Position},
													Settings = {Yield=true}

												},
											},
										})
									end)
								end
							end
						end)
					end
				end
			end)
		end
		usingarmL = true
		lookmouse = false
		task.delay(.6,function()
			walkspeed=30
			cooldown = false
		end)
	elseif(io.KeyCode == Enum.KeyCode.Q)then
		if (Movement.Position.p-mouse.Hit.p).Magnitude>1000 then
			return
		end
		local mo = mouse.Hit * mouse.Hit.Rotation:Inverse()
		cooldown = true
		PlaySound("rbxassetid://6162449120",mo,mrandom(.8,1), 2)
		local pos = CFrame.new(mo.p+Vector3.new(0,1.5*2,0))*Movement.Position.Rotation
		Movement.Position = pos
		task.delay(.15,function()
			cooldown = false
		end)
		mo=mo+Vector3.new(0,1.5*2,0)
		task.spawn(function() Module.Effect.TW({
			StartProps = {
				CFrame=mo,
				Color=Color3.new(0, 1, 0),
				Size=Vector3.new(5,12,5)/3,
				Material = "Neon",
				Transparency=.7
			},
			TweenList = {
				{
					TweenInfo={1},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},
				{
					TweenInfo={.9},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},

				{
					TweenInfo={.6},
					TweenProperties={Size=Vector3.new(),Color=Color3.new(),CFrame=mo*CFrame.new(0,-3,0)*randomangle()},
					Settings = {Yield=true}
				},
			},
			}) end)
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0),Transparency1=.3, LifeTime=20, Size1=Vector3.new(),Size2=Vector3.new(20,1,20),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0), LifeTime=15,Transparency1=.3, Size1=Vector3.new(1,0,1),Size2=Vector3.new(1,30,1),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})

		local parts = checkregion(mo.p, 8)
		for j,v in ipairs(parts) do
			task.spawn(function()
				if(not kill(v))then return end
				for i,face in ipairs(Enum.NormalId:GetEnumItems()) do
					local Size = v.Size
					local CF = v.CFrame

					if face == Enum.NormalId.Top or face ==  Enum.NormalId.Bottom then
						Size = Vector3.new(v.Size.X,0,v.Size.Z)
						CF = CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.Y/2)
					elseif face == Enum.NormalId.Front or face == Enum.NormalId.Back then
						Size = Vector3.new(v.Size.X, v.Size.Y, 0)
						CF = CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.Z/2)
					else
						Size = Vector3.new(0, v.Size.Y, v.Size.Z)
						CF =CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.X/2)
					end
					Module.Effect.TW({
						StartProps = {
							CFrame=CF,
							Color=v.Color,
							Size=Size,
							Material = v.Material,
							Transparency=v.Transparency,
							TopSurface = v.TopSurface,
							RightSurface = v.RightSurface,
							LeftSurface = v.LeftSurface, 
							FrontSurface = v.FrontSurface,
							BackSurface = v.BackSurface,
							BottomSurface = v.BottomSurface,
							CastShadow = v.CastShadow
						},
						TweenList = {
							{
								TweenInfo={1.6+(j/#parts)+(i/6)},
								TweenProperties={Size=Size},
								Settings = {Yield=true}
							},
							{
								TweenInfo={3,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
								TweenProperties={Position=v.Position+cfoffset(6+v.Size.Magnitude).p,Transparency=1},
								Settings = {Yield=true,Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))}
							},
						},
					})

				end
			end)
		end
	elseif(io.KeyCode == Enum.KeyCode.G)then
		if Movement.Walking or switching then
			return
		end
		switching = true
		walkspeed = 0
		cangun=not cangun

		if not cangun then
			for ind = 1, 60, 3 do
				for i, v in next, transparency do
					if(i:find("Gun"))then
						transparency[i] = (origtransparency[i] - 1) + (ind/60)
					end
				end
				task.wait()
			end
			for i, v in next, transparency do
				if(i:find("Gun"))then
					transparency[i] = origtransparency[i]
				end
			end
		else
			for ind = 1, 60, 3 do
				for i, v in next, transparency do
					if(i:find("Gun"))then
						transparency[i] = origtransparency[i] - (ind/60)
					end
				end
				task.wait()
			end
			for i, v in next, transparency do
				if(i:find("Gun"))then
					transparency[i] = origtransparency[i] - 1
				end
			end
		end

		task.wait(.3)
		walkspeed = 30
		switching = false
	elseif(io.KeyCode == Enum.KeyCode.Z)then
		if (Movement.Position.p-mouse.Hit.p).Magnitude>1000 or Movement.Falling or Movement.Walking or not cangun then
			return
		end
		cooldown = true
		lookmouse = true
		walkspeed=0
		disableanim = true
		local c;c= game:GetService("RunService").Heartbeat:Connect(function()
			animate("Head",CFrame.new(0,0,math.rad(5))*CFrame.Angles(math.rad(10),0,0),.2)
			animate("Torso",CFrame.new()*CFrame.Angles(math.rad(14),0,0),.2)
			animate("Right Arm",CFrame.new(-.4,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(-15)),.2)
			animate("Left Arm",CFrame.new(1,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(50)),.2)
			animate("Right Leg",CFrame.new(0,0,math.rad(14))*CFrame.Angles(math.rad(-14),0,0),.2)
			animate("Left Leg",CFrame.new(0,0,math.rad(20))*CFrame.Angles(math.rad(-20),0,0),.2)
			animate("Gun",CFrame.new(.6,-.3,0)*CFrame.Angles(0,math.rad(-15),0)*CFrame.new(-1.1,0,0),.2)
		end)
		task.wait(.6)
		c:Disconnect()
		local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
		PlaySound("rbxassetid://7378960134", Barrel, mrandom(.8,1.2), 2)
		task.spawn(function()
			local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
			local last = Barrel.p
			local awog = (Barrel*CFrame.new(-1.5*2,0,0)*cfoffset(1.5))
			local lastb = Barrel.p
			local Points = PointLightning(Barrel.p,awog.p, 18, .6)
			local lt = .5
			local Points2 = PointLightning(Barrel.p,awog.p, 18, .6) 
			local waa = {}
			for i,v in ipairs(Points2) do
				local Point, Distance = DrawPoint(lastb, v)
				waa[i] = {Point, Distance}
				lastb = v
			end
			--				--	Color3.fromHSV(0.05, 1, math.random())
			Module.Effect.new({StartCF=Barrel*randomangle(),Material="Glass",Size1=Vector3.new(0,0,.8),Size2=Vector3.new(.4,.4,.8),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1})
			for i,v in ipairs(Points) do
				local Point, Distance = DrawPoint(last, v)
				task.spawn(function() Module.Effect.TW({
					StartProps = {
						CFrame=Point,
						Color=Color3.fromHSV(0.05, 1, math.random()),
						Size=Vector3.new(.5,.5,Distance),
						Transparency=1
					},
					TweenList = {
						{
							TweenInfo={lt/1.5},
							TweenProperties={Transparency=0,Size=Vector3.new(.05,.05,Distance)},
							Settings = {Yield=true}
						},
						{
							TweenInfo={lt*1.5},
							TweenProperties={Transparency=1},
						},
						{
							TweenInfo={lt/2},
							TweenProperties={Size=Vector3.new(.15,.15,Distance)},
							Settings = {Yield=true}
						},
						{
							TweenInfo={lt*4},
							TweenProperties={Size=Vector3.new(.15,.15,waa[i][2]),CFrame=waa[i][1]},
							Settings = {Yield=true}
						},
					},
					}) end)
				last=v
				if i == #Points or i == 1   then
					Module.Effect.new({StartCF=Point*CFrame.new(0,0,-Distance/2)*randomangle(),Material="Glass",Size1=Vector3.new(0,0,.8),Size2=Vector3.new(.4,.4,.8),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1})
				end
				task.wait(.03)
			end
		end)
		lookmouse = false
		Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(2.5,2.5,2.5),radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Color2=Color3.new(),LifeTime=15,Transparency2=1})
		Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(2.5,2.2+.5,2.5),radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Color2=Color3.new(),LifeTime=20,Transparency2=1,Shape="Ball"})
		for i = 1, 3 do
			Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(.15,14,.15),radX=mrandom(-12,12),radY=mrandom(-12,12),radZ=mrandom(-12,12),Color2=Color3.new(),LifeTime=23,Transparency2=1,Shape="Ball"})
		end
		task.spawn(function()
			local hit = mouse.Hit
			local dis = (Barrel.p-hit.p).Magnitude
			local ha = 30+math.clamp(dis/100, 0, 20)
			local bez = Bezier.new(Barrel.p,Barrel.p + Vector3.new(0,ha/4,0), hit.p + Vector3.new(0,ha*1.5 ,0),hit.p)
			local path = bez:GetPath(.2 - math.clamp(dis/1000, 0, .05))
			local last = Barrel.p
			local increase = 0
			for i,v in ipairs(path) do
				increase=increase+.3
				local Offset = cfoffset(increase).p
				if i == #path then
					Offset=Vector3.new()
					for i,v in ipairs(checkregion(v, 12)) do
						task.spawn(function()
							if(not kill(v))then return end
							local a = newpart()
							a.Size=v.Size
							a.CFrame=v.CFrame
							a.Color=Color3.new(1,mrandom(.1,.3),0)
							a.Material="Neon"
							a.Anchored=true
							tween(a, {6+math.random()},{Transparency=1,Color=Color3.new()}).Completed:Connect(function()
								destroy(a)
							end)
							task.delay(2,function()
								a.Anchored=false
							end)
						end)
					end
				end
				v=v+Offset
				local thickness = 1
				local Point,Distance = DrawPoint(last,v)
				Module.Effect.new({StartCF=Point*CFrame.Angles(math.rad(90),math.rad(90),0),Shape="Cylinder",Color1=Color3.new(1, .4,0),Color2=Color3.new(),Transparency2=1,Size1=Vector3.new(thickness,Distance,thickness),Size2=Vector3.new(0,Distance,0),LifeTime=20})
				local lt = 1
				last=v


				if i == #path then
					task.spawn(function()
						local hit = hit*hit.Rotation:Inverse()
						for i = 1, math.random(14,27) do

							Module.Effect.new({StartCF=hit, Size1=Vector3.new(0,.1,0),Color1=Color3.new(1, .5,0),Color2=Color3.new(),Shape="Ball",Size2=Vector3.new(9,.1,9),Transparency2=1,LifeTime=25})
							local whereto = hit.p+Vector3.new(mrandom(-35,35),0,mrandom(-35,35))
							task.spawn(function()
								local wcf = CFrame.new(whereto)
								local dis = (hit.p - whereto).Magnitude
								local incr = math.random(4)
								local bez = Bezier.new(hit.p,hit.p + Vector3.new(0,dis*incr,0), whereto + Vector3.new(0,dis*incr ,0),whereto)
								local amo = .03
								if dis < 5  then
									amo = .01
								end
								local path = bez:GetPath(.1)
								local last = hit.p

								for i,v in ipairs(path) do
									local Point, Distance = DrawPoint(last, v)
									Module.Effect.new({StartCF=Point*CFrame.Angles(math.rad(90),math.rad(90),0),Size1=Vector3.new(1,Distance,1), Shape = "Cylinder", Color1=randomtable({Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.35,0)}), Color2=Color3.new(),Size2=Vector3.new(0,Distance,0), LifeTime=25,Transparency2=1})
									last=v

									if i == #path then
										PlaySound("rbxassetid://4307214211", wcf, mrandom(.8,1.2), .6)
										PlaySound("rbxassetid://3750957896", wcf, mrandom(.8,1.2), .8, 0)
										Module.Effect.new({StartCF=wcf*randomangle(), Color1=Color3.new(1,.3,0),Transparency2=1,Color2=Color3.new(),Size1=Vector3.new(),Size2=Vector3.new(20,20,20),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),LifeTime=30})
										Module.Effect.new({Shape="Ball",StartCF=wcf*randomangle(), Color1=Color3.new(1,.3,0),Transparency2=1,Color2=Color3.new(),Size1=Vector3.new(),Size2=Vector3.new(23,23,23),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),LifeTime=35})
										for i = 1, math.random(3,6) do
											Module.Effect.new({StartCF=wcf*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(1,60,1),radX=mrandom(-9,9),radY=mrandom(-9,9),radZ=mrandom(-9,9),Color2=Color3.new(),LifeTime=35,Transparency2=1,Shape="Ball",Transparency1=.3})
										end
										for i = 1, math.random(3) do
											Module.Effect.new({StartCF=wcf*randomangle(),Shape="Ball",Size1=Vector3.new(),Size2=Vector3.new(3,8,3),Color1=Color3.new(1,.15,0),Color2=Color3.new(1,.15,0),Transparency2=1,LifeTime=35,radX=mrandom(-3,3),radY=mrandom(-3,3),radZ=mrandom(-3,3), MoveTo=wcf*cfoffset(10)})
										end
										for i,v in ipairs(checkregion(v, 12)) do
											task.spawn(function()
												if(not kill(v))then return end
												local a = newpart()
												a.Size=v.Size
												a.CFrame=v.CFrame
												a.Color=Color3.new(1,mrandom(.1,.3),0)
												a.Material="Neon"
												a.Anchored=true
												tween(a, {6+math.random()},{Transparency=1,Color=Color3.new()}).Completed:Connect(function()
													destroy(a)
												end)
												task.delay(2,function()
													a.Anchored=false
												end)
											end)
										end
									end
									task.wait(amo)
								end
							end)

							task.wait(.15)
						end
					end)
				end
				task.wait(.03)
			end
		end)
		local c;c= game:GetService("RunService").Heartbeat:Connect(function()
			animate("Head",CFrame.new(0,0,math.rad(5))*CFrame.Angles(math.rad(10),0,0),.2)
			animate("Torso",CFrame.new()*CFrame.Angles(math.rad(14),0,0),.2)
			animate("Right Arm",CFrame.new(-.7,1,-1)*CFrame.Angles(math.rad(160),math.rad(-35),math.rad(-15)),.6)
			animate("Left Arm",CFrame.new(1,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(50)),.6)
			animate("Right Leg",CFrame.new(0,0,math.rad(14))*CFrame.Angles(math.rad(-14),0,0),.2)
			animate("Left Leg",CFrame.new(0,0,math.rad(20))*CFrame.Angles(math.rad(-20),0,0),.2)
			animate("Gun",CFrame.new(.6,-.3,0)*CFrame.Angles(math.rad(25),math.rad(-15),0)*CFrame.new(-1.1,0,0),.6)
		end)
		task.wait(.09)
		c:Disconnect()

		disableanim = false

		walkspeed=30
		task.delay(.4,function()
			cooldown = false
		end)
	end
end)

local holdingmouse = false
mouse.Button1Down:Connect(function()
	holdingmouse = true
end)
mouse.Button1Up:Connect(function()
	holdingmouse = false
end)

local increment = 0
function getXAndZPositions(angle, radius)
	local x = math.cos(angle) * radius
	local z = math.sin(angle) * radius
	return x, z
end
function shootgun()		
	if not cangun or Movement.Walking then return end
	if cooldown then
		return
	end
	increment=math.clamp(increment+.05, 0, .21)
	lookmouse = true
	cooldown = true
	usingarmR = false
	usingarmL = false
	usingtorso = false
	walkspeed=0

	local c;c= game:GetService("RunService").Heartbeat:Connect(function()
		animate("Right Arm", CFrame.new(.3,.5,-.6)*CFrame.Angles(math.rad(90),0,math.rad(45)),.25)
		animate("Torso", CFrame.Angles(0,math.rad(45),0), .25)
		animate('Gun', CFrame.new(0,-.3,0)*CFrame.Angles(0,0,0),.25)
		animate("Left Arm",CFrame.new(math.rad(-3),0,0)*CFrame.Angles(0,0,math.rad(-6)), .25)
	end)
	task.wait(.15)

	c:Disconnect()
	local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
	PlaySound("rbxassetid://5773418559",Barrel, mrandom(.5,.7), 1.5)
	local P = Barrel
	local bolts = math.random(4,5)
	local distance = (Barrel.p-mouse.Hit.p).Magnitude
	local ori = mrandom(-360,360)
	local MaxBoltHeight = math.clamp(distance, 10, 80)
	local circ = 2 * math.pi
	local hit = mouse.Hit
	local exploding = false
	for i = 1, math.random(4,8) do
		task.spawn(function()
			local del = math.random()/6
			task.wait(del)
			local spread = cfoffset(6).p
			local gwa = CFrame.new(Barrel.p, hit.p+spread)*CFrame.new(0,0,-distance/1.2).Position+cfoffset(MaxBoltHeight).p

			local bez = Bezier.new(Barrel.p,gwa,hit.p+spread)
			local path = bez:GetPath(.2 - math.clamp(distance/1000, 0, .05))
			local last = Barrel.p
			local wa = .03 * math.clamp(distance / 100, 0, 2)
			local color = Color3.new(1,.3,0)
			if math.random(2)==1 then
				color = Color3.new(1,.3,.3)
			end
			for i,v in ipairs(path) do
				task.spawn(function()
					local offset = cfoffset(2).p
					if i == 1 or i == #path then
						offset=Vector3.new()
					end
					v=v+offset
					local lt = 1
					local Point, Distance = DrawPoint(last, v)
					task.spawn(function() Module.Effect.TW({
						StartProps = {
							CFrame=Point,
							Color=Color3.new(1,1,1),
							Size=Vector3.new(.3,.3,Distance)
						},
						TweenList = {
							{
								TweenInfo={lt},
								TweenProperties={Transparency=1,Color=color},
								Settings = {Yield=true}
							},
						},
						}) end)

					last=v

					if i==#path and not exploding then
						local 	hit=hit*hit.Rotation:Inverse()
						Point=Point*Point.Rotation:Inverse()
						exploding=true
						local wa = cfoffset(30)
						PlaySound("rbxassetid://3750957896", Point, mrandom(.6,.8), 4, 0)

						--time, style, direction, repeatcount, reverses
						local wh = CFrame.new(hit*cfoffset(30).p, hit.p)


						--effect2(StartProperties:{}, TweenList:{TweenInfo:{}, TweenProperties{}, TweenSettings:{Yield}})

						task.spawn(function() Module.Effect.TW({
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,.15,0),

							},
							TweenList = {
								{
									TweenInfo={4.5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1.4},
									TweenProperties={Size=Vector3.new(30,30,30)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={2},
									TweenProperties={Color=Color3.new()},
								},
								{
									TweenInfo={1.3,Enum.EasingStyle.Quart,Enum.EasingDirection.In},
									TweenProperties={Size=Vector3.new(0,50,0)},
									Settings = {Yield=true,MulSpin=8}
								}
							},
							Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))

							}) end)
						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(),
								Size = Vector3.new(4,5,6)

							},
							TweenList = {
								{
									TweenInfo={5.5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1.75},
									TweenProperties={Size=Vector3.new(20,20,20)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={3.3},
									TweenProperties={Size=Vector3.new(0,30,0),Color=Color3.new(1,1,1)},
									Settings = {Yield=true}
								}
							},
							Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))

							}) end)
						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,1,1),
								Size = Vector3.new(),
								Transparency=.1

							},
							TweenList = {
								{
									TweenInfo={4},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut,0,true},
									TweenProperties={Size=Vector3.new(50,50,60)},
								},
								{
									TweenInfo={.5},
									TweenProperties={Color=Color3.new(1,.3,.3)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={.5},
									TweenProperties={Color=Color3.new(1,.15,0)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={1.5},
									TweenProperties={Color=Color3.new()},
									Settings = {Yield=true}
								},
							},
							Spin=CFrame.Angles(math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)))

							}) end)


						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,1,1),
								Size=Vector3.new(2,7,2)
							},
							TweenList = {
								{
									TweenInfo={5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1},
									TweenProperties={Color=Color3.new(1,.15,0),Size=Vector3.new(30,30,30)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={2},
									TweenProperties={CFrame=hit*cfoffset(40)*randomangle(),Size=Vector3.new(0,30,0)},
									Settings = {Yield=true}
								},
							},
							Spin=CFrame.Angles(math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)))

							})
						end)

						for i,v in ipairs(checkregion(hit.p, 25)) do
							task.spawn(function()
								if(not kill(v))then return end
								PlaySound(randomtable({"rbxassetid://4988577600","rbxassetid://4988577985","rbxassetid://4988578264"}),Point, mrandom(.8,1.2),2)
								local a= newpart()
								a.Anchored = false
								a.CFrame=v.CFrame
								a:BreakJoints()
								a.Color=v.Color
								a.Material=v.Material
								a.Size=v.Size
								task.delay(2,function()
									tween(a, {2},{Transparency=1}).Completed:Connect(function()
										destroy(a)
									end)
								end)
							end)
						end
					end
				end)
				task.wait(wa)
			end
		end)
	end
	local c;c= game:GetService("RunService").Heartbeat:Connect(function()
		animate("Right Arm", CFrame.new(.3,.7,-.6)*CFrame.Angles(math.rad(140),0,math.rad(45)),.3)
		animate("Torso", CFrame.Angles(0,math.rad(45),0), .3)
		animate('Gun', CFrame.new(0,-.3,0)*CFrame.Angles(0,0,0),.3)
	end)
	task.wait(.06)
	c:Disconnect()
	task.delay(.2-increment,function()
		cooldown = false
		lookmouse = false
		usingarmR = true
		usingarmL = true
		usingtorso = true
		walkspeed=30
		task.delay(.1,function()
			if lookmouse == false then
				increment = 0
			end
		end)
	end)
end

local dt = 0
local Sine = 0
game:GetService("RunService").Heartbeat:Connect(function(delta)
	dt = dt + delta
	if(plr.Character)then
		plr.Character:PivotTo(CFrame.new(9e9, 9e9, 9e9))
	end

	Sine = os.clock()*60

	if(Movement.Flying)then
		if math.random(9)==1 then
			task.spawn(function() Module.Effect.new({
				StartCF=Movement.Position*CFrame.new(0,-3,0)*radiananglefrom(3),
				Size1=Vector3.new(20,.5,20),
				Size2=Vector3.new(0,.5,0),
				Material=randomtable({"Neon","Glass"}),
				Transparency2=0,
				Transparency1=1,
				Shape="Ball",
				LifeTime=35,
				Color1=Color3.fromHSV(0.05, 1, math.random()),
				Color2=Color3.fromHSV(0.05, 1, math.random())
				}) end)
		end
	end

	task.spawn(function()
		if(cangun)then
			if math.random(100)==1 then
				local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
				local last = Barrel.p
				local awog = (Barrel*CFrame.new(-1.5*2,-2,0)*cfoffset(3))
				local params = RaycastParams.new()
				params.RespectCanCollide = true
				params.FilterDescendantsInstances = parts
				params.FilterType = Enum.RaycastFilterType.Exclude
				local ray = workspace:Raycast(last, awog.p - last, params)
				if ray then
					awog = CFrame.new(ray.Position)
				end
				local lastb = Barrel.p
				local Points = PointLightning(Barrel.p,awog.p, 18/3, .6)
				local lt = .5
				local Points2 = PointLightning(Barrel.p,awog.p, 18/3, .6) 
				local waa = {}
				for i,v in ipairs(Points2) do
					local Point, Distance = DrawPoint(lastb, v)
					waa[i] = {Point, Distance}
					lastb = v
				end
				task.spawn(function() Module.Effect.new({StartCF=Barrel,Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(.8,.4,.4),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=25,Transparency2=1}) end)
				for i,v in ipairs(Points) do
					local Point, Distance = DrawPoint(last, v)
					task.spawn(function() Module.Effect.TW({
						StartProps = {
							CFrame=Point,
							Color=Color3.fromHSV(0.05, 1, math.random()),
							Size=Vector3.new(.5,.5,Distance),
							Transparency=1
						},
						TweenList = {
							{
								TweenInfo={lt/1.5},
								TweenProperties={Transparency=0,Size=Vector3.new(.05,.05,Distance)},
								Settings = {Yield=true}
							},
							{
								TweenInfo={lt*1.5},
								TweenProperties={Transparency=1},
							},
							{
								TweenInfo={lt/4},
								TweenProperties={Size=Vector3.new(.15,.15,Distance)},
								Settings = {Yield=true}
							},
							{
								TweenInfo={lt*4},
								TweenProperties={Size=Vector3.new(.15,.15,waa[i][2]),CFrame=waa[i][1]},
								Settings = {Yield=true}
							},
						},
						}) end)
					last=v
					if i == #Points then
						task.spawn(function() Module.Effect.new({StartCF=Point*CFrame.new(0,0,-Distance/2)*randomangle(),Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(.2,.2,.4),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1}) end)
					end
					task.wait(.03)
				end
			end
		end
	end)

	if(holdingmouse and not Movement.Falling and cangun)then
		shootgun()
	end

	if(lookmouse)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Vector3.new(mouse.Hit.X, Movement.Position.Y, mouse.Hit.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, mouse.Hit.Position)
		end
	end

	local anim = {}
	if(not disableanim)then
		if(not Movement.Walking and not Movement.Falling and not Movement.Jumping)then
			if cangun then
				local tiltam = .04
				animate("Head",CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),.1)
				if usingtorso then
					animate("Torso",CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0)*CFrame.new(0,0,.1)*CFrame.Angles(math.rad(-2)+.02*math.cos(Sine/25),math.rad(-15),math.rad(2)),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),.1)
				end
				animate("Right Leg",CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0),.1)
				animate("Left Leg",CFrame.new(),.1)
				if usingtorso then
					animate("Gun", CFrame.new(.6,-1.45,0)*CFrame.Angles(math.rad(-0),0,math.rad(70)), .3)
				end
			else
				local tiltam = .04
				animate("Head",CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),.1)
				if usingtorso then
					animate("Torso",CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),.1)
				end
				animate("Right Leg",CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0),.1)
				animate("Left Leg",CFrame.new(),.1)
			end
		end

		if(Movement.Jumping)then
			anim = {
				["Head"] = CFrame.new(0,0,.1)*CFrame.Angles(math.rad(15),0,0),
				Torso = CFrame.new()*CFrame.Angles(math.rad(6),0,0),
				["Right Arm"] = CFrame.new(.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(80)),
				["Left Arm"] = CFrame.new(-.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(-80)),
				["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-15),math.rad(5),0),
				["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
			}
			if cangun and usingtorso then
				animate("Gun", CFrame.new(), 1)
			end
		elseif(Movement.Falling)then
			anim = {
				["Head"] = CFrame.new(0,0,-.1)*CFrame.Angles(math.rad(-25),0,0),
				Torso = CFrame.new()*CFrame.Angles(math.rad(-15),0,0),
				["Right Arm"] = CFrame.new(.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(125)),
				["Left Arm"] = CFrame.new(-.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(-125)),
				["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-35),math.rad(5),0),
				["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
			}
			if cangun and usingtorso then
				animate("Gun", CFrame.new(), 1)
			end
		end

		if(Movement.Walking and not Movement.Jumping and not Movement.Falling)then
			if cangun then
				animate("Head",CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),.1)
				if usingtorso then
					animate("Torso",CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmR  then
					animate("Right Arm",CFrame.new(0,1.3,-.35)*CFrame.Angles(math.rad(145)-.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				end
				animate("Right Leg",CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				animate("Left Leg",CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				if usingtorso then
					animate("Gun",CFrame.new(), .3)
				end
			else
				animate("Head",CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),.1)
				if usingtorso then
					animate("Torso",CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,0,0-(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				end
				animate("Right Leg",CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				animate("Left Leg",CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
			end
		end
	end

	if(not usingarmL)then
		anim["Left Arm"] = nil
	end
	if(not usingarmR)then
		anim["Right Arm"] = nil
	end
	if(not usingtorso)then
		anim["Torso"] = nil
	end

	animate(anim)

	cframes["Torso"] = Movement.Position*offsets["Torso"]
	cframes["Head"] = cframes["Torso"]*offsets["Head"]
	cframes["Right Arm"] = cframes["Torso"]*offsets["Right Arm"]
	cframes["Right Leg"] = cframes["Torso"]*offsets["Right Leg"]
	cframes["Left Arm"] = cframes["Torso"]*offsets["Left Arm"]
	cframes["Left Leg"] = cframes["Torso"]*offsets["Left Leg"]
	cframes["Gun"] = cframes["Right Arm"]*offsets["Gun"]
	cframes["Gun_FadeB"] = cframes["Right Arm"]*offsets["Gun"]*offsets["Gun_FadeB"]
	cframes["Gun_Crystal"] = cframes["Right Arm"]*offsets["Gun"]*offsets["Gun_Crystal"]

	for i, v in next, limbs do
		v.CFrame = cframes[i]
	end

	if(dt < 1/30)then
		return
	end
	dt = 0
	for i, v in next, {"Torso", "Left Arm", "Left Leg", "Head", "Right Arm", "Right Leg", "Gun", "Gun_FadeB", "Gun_Crystal"} do
		task.spawn(createlimb, v)
	end

	local changecolor = {}
	local changematerial = {}
	local changeresize = {}
	local changemesh = {}
	local changeanchor = {}
	for i, v in next, parts do
		table.insert(changecolor, {
			Part = replicatedparts[v], Color = v.Color
		})
		table.insert(changematerial, {
			Part = replicatedparts[v], Material = v.Material, Transparency = v.Transparency,
			Reflectance = v.Reflectance
		})
		table.insert(changeresize, {
			Part = replicatedparts[v], Size = v.Size, CFrame = v.CFrame
		})
		local m = v:FindFirstChildOfClass("SpecialMesh")
		if(m)then
			table.insert(changemesh, {
				Part = replicatedparts[v], MeshType = m.MeshType, Scale = m.Scale, MeshId = m.MeshId
			})
		end
		if(not v.Anchored)then
			table.insert(changeanchor, {
				Part = replicatedparts[v], Anchored = v.Anchored
			})
		end
	end
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncResize', changeresize)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncColor', changecolor)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncMaterial', changematerial)
	if(#changemesh >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncMesh', changemesh)
	end
	if(#changeanchor >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncAnchor', changeanchor)
	end
end)