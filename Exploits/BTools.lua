local plr = game:GetService("Players").LocalPlayer
local btools;
local syncapi;
if(not plr.Character)then repeat task.wait() until plr.Character end

local startpos = plr.Character:WaitForChild("HumanoidRootPart").CFrame

print'waiting'

repeat task.wait() until plr.Backpack:FindFirstChild("ServerEndpoint", true) and plr.Backpack:FindFirstChild("ServerEndpoint", true):IsA("RemoteFunction")

print'got sync'

syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
btools = syncapi.Parent.Parent

game:GetService("RunService").Heartbeat:Connect(function()
	pcall(function()
		btools.Parent = plr.Backpack
	end)
	syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
	btools = syncapi.Parent.Parent
	btools.Parent = plr.Backpack
end)

local ArtificialHB = Instance.new("BindableEvent")
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/60
game:GetService("RunService").Heartbeat:Connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire(1/60)
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire(1/60)
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

local parts = {}

local Movement = {
	Position = startpos,
	FakePosition = startpos,
	MouseHit = CFrame.identity,
	Jumping = false,
	Falling = false,
	Walking = false,
	Flying = false,
}

local oldmainpos, walkspeed, gravityvelocity = Movement.Position, 30, 0
local w, a, s, d = false, false, false, false

local movementkeys = {
	w = function(up, io)
		w = not up
	end,
	a = function(up, io)
		a = not up
	end,
	s = function(up, io)
		s = not up
	end,
	d = function(up, io)
		d = not up
	end,
	f = function(up, io)
		if(not up)then
			Movement.Flying = not Movement.Flying
		end
	end,
	space = function(up, io)
		if(not up and not Movement.Falling and not Movement.Jumping and not Movement.Flying)then
			Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis/2)
			gravityvelocity = (1/60)*30
		end
	end,
}

local mouse = plr:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(false, io)
	end
end)

game:GetService("UserInputService").InputEnded:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(true, io)
	end
end)

local campart = Instance.new("Part")
campart.Size = Vector3.zero
campart.Transparency = 1
campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)

local muspart = Instance.new("Part")
muspart.Size = Vector3.zero
muspart.Transparency = 1
muspart.CFrame = Movement.Position

ArtificialHB.Event:Connect(function(dt)
	if(not campart) or (not pcall(function()
			campart.Parent = nil
			campart.CFrame = campart.CFrame
		end))then
		pcall(game.Destroy, campart)
		campart = Instance.new("Part")
		campart.Size = Vector3.zero
		campart.Transparency = 1
		campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)
	end
	if(not muspart or not pcall(function()
			muspart.Parent = game:GetService("JointsService")
			muspart.CFrame = muspart.CFrame
		end))then
		pcall(game.Destroy, muspart)
		muspart = Instance.new("Part")
		muspart.Size = Vector3.zero
		muspart.Transparency = 1
		muspart.CFrame = Movement.Position
		muspart.Parent = game:GetService("JointsService")
	end
	pcall(function()
		workspace.CurrentCamera.CameraSubject = campart
	end)
	muspart.CFrame = Movement.Position
	if(not muspart:FindFirstChildOfClass("Sound"))then
		local s = Instance.new("Sound", muspart)
		s.Volume = 1
		s.SoundId = "rbxasset://music/Invaders.mp3"
		s.Looped = true
		s.Playing = true
	end
end)

local realRotation = CFrame.identity
local momentum = 0
local momentummax = 40
local momentumspeed = 5
local walkingtime = os.clock()

local lastframe = os.clock()
local deltamult = 1

local function deltaclamp(val)
	return math.clamp(val*deltamult, 0, 1)
end

ArtificialHB.Event:Connect(function(delta)
	deltamult = 60*(os.clock() - lastframe)
	lastframe = os.clock()
	campart.CFrame = campart.CFrame:Lerp(Movement.Position*CFrame.new(0,1.5,0), deltaclamp(.3))

	oldmainpos = Movement.Position
	local shiftlock =  game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter

	if(not Movement.Flying)then
		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {workspace.Terrain}
		local ray = workspace:Raycast(Movement.Position.Position, Vector3.new(0,-3.1,0), param)
		if(ray)then
			Movement.Position = Movement.Position * CFrame.new(0,ray.Position.Y-Movement.Position.Y+3,0)
			gravityvelocity = 0
		else
			gravityvelocity = gravityvelocity - (((1/60)*1.4*(workspace.Gravity/196.2))*deltamult)
		end
	else
		gravityvelocity = 0
	end

	if(w or a or s or d)and(walkspeed>0)then
		Movement.Walking = true
	else
		Movement.Walking = false
		walkingtime = os.clock()
		momentum = 0
	end

	local fakewalkspeed = walkspeed

	if(Movement.Flying)then
		momentum = math.clamp((os.clock() - walkingtime) * momentumspeed, 0, momentummax)
	end
	fakewalkspeed = fakewalkspeed + momentum

	if(w and d)or(w and a)or(s and d)or(s and a)then
		fakewalkspeed = fakewalkspeed/1.4
	end

	local camlook = workspace.CurrentCamera.CFrame.LookVector

	if(Movement.Walking)and(not shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	elseif(shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	end

	if(w)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(a)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end
	if(s)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(d)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end

	if(not shiftlock)and(Movement.Position.X ~= oldmainpos.X)and(Movement.Position.Z ~= oldmainpos.Z)then
		Movement.Position = CFrame.new(Movement.Position.Position) * realRotation.Rotation

		if(Movement.Walking)and(not Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, 0, look.Z)), deltaclamp(math.pi/16))
		elseif(Movement.Walking)and(Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, look.Y, look.Z)), deltaclamp(math.pi/16))
		end

		realRotation = Movement.Position.Rotation
	end

	if(Movement.Position.Y < -200)then
		Movement.Position = CFrame.new(0,20,0)
		gravityvelocity = 0
	end

	Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis*gravityvelocity)

	if(not Movement.Flying)then
		if(oldmainpos.Y > Movement.Position.Y)then
			Movement.Falling = true
			Movement.Jumping = false
		elseif(oldmainpos.Y < Movement.Position.Y)then
			Movement.Falling = false
			Movement.Jumping = true
		else
			Movement.Falling = false
			Movement.Jumping = false
		end
	else
		Movement.Falling = false
		Movement.Jumping = false
	end
end)

local limbs = {}
local cframes = {}

local sizes = {
	["Torso"] = Vector3.new(2, 2, 1),
	["Right Arm"] = Vector3.new(1, 2, 1),
	["Left Arm"] = Vector3.new(1, 2, 1),
	["Right Leg"] = Vector3.new(1, 2, 1),
	["Left Leg"] = Vector3.new(1, 2, 1),
	["Head"] = Vector3.new(1.025, 1.025, 1.025),
	["Gun"] = Vector3.new(3.289, 1.935, 0.745),
	["Gun_FadeB"] = Vector3.new(0.5, 0.555, 0.555),
	["Gun_Crystal"] = Vector3.new(0.14, 0.186, 0.186),
	["Ears"] = Vector3.new(1.526, 0.905, 0.735),
	["Tail"] = Vector3.new(1.159, 2.374, 3.484)
}
local materials = {
	["Gun_Crystal"] = Enum.Material.Neon,
	["Gun_FadeB"] = Enum.Material.Neon,
}
local colors = {
	["Torso"] = Color3.fromRGB(255, 100, 53),
	["Gun_FadeB"] = Color3.fromRGB(255, 89, 89),
	["Gun_Crystal"] = Color3.fromRGB(4, 175, 236)
}
local reflectance = {
	["Torso"] = -.5,
	["Gun"] = .2
}
local meshes = {
	["Gun"] = "rbxassetid://6120339872",
	["Gun_FadeB"] = "rbxassetid://6120345442",
	["Head"] = "rbxasset://fonts/head.mesh",
	["Left Arm"] = "rbxasset://fonts/leftarm.mesh",
	["Left Leg"] = "rbxasset://fonts/leftleg.mesh",
	["Right Arm"] = "rbxasset://fonts/rightarm.mesh",
	["Right Leg"] = "rbxasset://fonts/rightleg.mesh",
	["Torso"] = "rbxasset://fonts//torso.mesh",
	["Tail"] = "rbxassetid://15239702663",
	["Ears"] = "rbxassetid://15239875418"
}
local meshscales = {
	["Gun"] = Vector3.new(.74, .74, .74),
	["Gun_FadeB"] = Vector3.new(.7,.7,.7),
	["Tail"] = Vector3.new(1,1,1)/100,
	["Ears"] = Vector3.new(1,1,1)/100
}
local transparency = {
	["Gun"] = 1,
	["Gun_FadeB"] = 1.7,
	["Gun_Crystal"] = 1
}
local origtransparency = table.clone(transparency)

local offsets = {
	["Torso"] = CFrame.identity,
	["Left Leg"] = CFrame.new(-.5, -2, 0),
	["Right Leg"] = CFrame.new(.5, -2, 0),
	["Right Arm"] = CFrame.new(1.5, 0, 0),
	["Left Arm"] = CFrame.new(-1.5, 0, 0),
	["Head"] = CFrame.new(0, 1.5, 0),
	["Gun"] = CFrame.new(-0.0219726562, -1.76120234, -0.487823486, 6.258486e-07, -6.63396293e-07, -1, 0.999999881, -1.90734772e-06, 6.25849793e-07, -1.90734841e-06, -1, 6.63395099e-07),
	["Gun_Crystal"] = CFrame.new(-1.57798314, 0.910415649, 0, 1, -1.8491927e-06, 5.25676569e-09, 1.30385047e-06, 0.707101941, 0.707111657, -1.31130253e-06, -0.707111657, 0.707101941),
	["Gun_FadeB"] = CFrame.new(-1.30953908, 0.663314819, 0, 1, -1.30384865e-06, 1.31130457e-06, 1.30385047e-06, 1, -1.445777e-06, -1.31130253e-06, 1.44577859e-06, 1),
	["Tail"] = CFrame.new(0.031, 1.172, -2.02):Inverse(),
	["Ears"] = CFrame.new(0, -0.556, 0.067):Inverse()
}
local origoffsets = table.clone(offsets)
local replicatedparts = {}

function checkregion(where, range)
	local params = OverlapParams.new()
	params.FilterDescendantsInstances = parts
	params.RespectCanCollide = false
	params.FilterType = Enum.RaycastFilterType.Exclude
	local da = {}
	for i,v in ipairs(workspace:GetPartBoundsInRadius(where, range, params)) do
		if(v.Name ~= "Baseplate" and v.Parent ~= workspace.Terrain and v.Size.X < 400)then
			table.insert(da,v)
		end
	end
	return da
end

local function kill(object)
	if(table.find(parts, object))then return end
	local parent = object.Parent
	syncapi:InvokeServer('Remove', {object})
	return object.Parent ~= parent
end

local function destroy(obj)
	local orig = obj

	if(replicatedparts[obj])then obj = replicatedparts[obj] end
	replicatedparts[orig] = nil

	if(table.find(parts, orig))then
		table.remove(parts, table.find(parts, orig))
	end

	orig:Destroy()
	syncapi:InvokeServer('Remove', {obj})
end

local function newpart()
	local p = syncapi:InvokeServer('CreatePart', 'Normal', CFrame.new(9e9, 9e9, 9e9), workspace.Terrain)
	p.Parent = game:GetService("ReplicatedStorage")
	p.Anchored = true

	local fakepart = Instance.new("Part")
	fakepart.CFrame = CFrame.new(9e9, 9e9, 9e9)
	fakepart.Anchored = true
	fakepart.TopSurface = Enum.SurfaceType.Smooth;
	fakepart.BottomSurface = Enum.SurfaceType.Smooth;
	table.insert(parts, fakepart)
	replicatedparts[fakepart] = p
	fakepart.Parent = workspace.Terrain

	return fakepart
end

local function createlimb(name)
	local limb = newpart()
	limbs[name] = limb

	limb.Material = materials[name] or Enum.Material.Glass
	limb.Transparency = 0
	limb.Anchored = true
	limb.Color = colors[name] or Color3.fromRGB(231, 231, 236)
	limb.Size = sizes[name] or Vector3.zero
	limb.CFrame = cframes[name] or CFrame.identity
	limb.Reflectance = reflectance[name] or 0
	limb.Transparency = transparency[name] or 0

	if(meshes[name])then
		task.spawn(function()
			task.spawn(function()
				syncapi:InvokeServer('CreateMeshes', {{
					Part = replicatedparts[limb]
				}})
			end)

			syncapi:InvokeServer('SyncMesh', {{
				Part = replicatedparts[limb], MeshType = Enum.MeshType.FileMesh,
				Scale = meshscales[name] or Vector3.one,
				MeshId = meshes[name]
			}})
		end)

		local mesh = Instance.new("SpecialMesh", limb)
		mesh.MeshType = Enum.MeshType.FileMesh
		mesh.MeshId = meshes[name]
		mesh.Scale = meshscales[name] or Vector3.one
	end

	repeat task.wait() until limbs[name] ~= limb
	destroy(limb)
end

local function PlaySound(id, cf, pit, vol, timepos)
	local temp = Instance.new("Attachment")
	temp.Name = ""

	temp.CFrame = cf
	local audio = Instance.new("Sound", temp)
	audio.Name = ""
	audio.PlayOnRemove = true
	audio.Pitch = pit
	audio.SoundId = id
	audio.Volume = vol
	temp.Parent = workspace.Terrain
	if timepos then
		audio.TimePosition = timepos
	end
	temp:Destroy()
end

local LightningBolt = {}
local ActiveEffects = {}
local Module = {
	Effect = {}
}
local tospin = {}
function Lerp3D(a, b, c, DeltaTime)
	return a:Lerp(b, 1 - c ^ DeltaTime)
end
function LerpNum(a, b, c, DeltaTime)
	return a + (b - a) * (1 - c ^ DeltaTime)
end
function tween(a,info, props)
	local re = game:GetService("TweenService"):Create(a, TweenInfo.new(table.unpack(info)), props)
	re:Play()
	return re
end
--effect2(StartProperties:{}, TweenList:{TweenInfo:{}, TweenProperties{}, TweenSettings:{Yield}})
function Module.Effect.TW(tbl)
	task.spawn(function()
		local dprops = tbl.StartProps
		local list = tbl.TweenList
		local new = newpart()
		new.Size = dprops.Size or Vector3.new()
		new.Material=dprops.Neon or "Neon"
		for prop in pairs(dprops) do
			new[prop]=dprops[prop]
		end
		if tbl.Spin  then
			tospin[new] = tbl.Spin
		end
		for index, info in ipairs(list) do
			local Settings =	info.Settings or {}
			if Settings.Spin then
				tospin[new] = Settings.Spin
			end
			local tw = tween(new, info.TweenInfo, info.TweenProperties)
			if Settings.MulSpin then
				for i = 1, Settings.MulSpin do
					tospin[new] = tbl.Spin * tbl.Spin
				end
			end
			if Settings.Yield then
				tw.Completed:Wait()
			end
			if index==#list or new == nil or new.Parent~=workspace.Terrain then
				destroy(new)
				break
			end
		end
	end)
end
function Module.Effect.colorshift3(tbl)
	task.spawn(function()
		local a = newpart()
		a.CFrame=tbl.CF
		a.Size=tbl.Size
		a.Color=tbl.C1
		a.Material="Neon"
		game:GetService("Debris"):AddItem(a, tbl.time)
		tween(a, {tbl.time}, {Transparency=1})
		tween(a, {tbl.time/2}, {Color=tbl.C2}).Completed:Wait()
		tween(a, {tbl.time/2}, {Color=tbl.C3})
	end)
end
function Module.Effect.new(tbl)	
	task.spawn(function() tbl.Color1 = tbl.Color1 or Color3.new()
		tbl.Color2 = tbl.Color2 or Color3.new()
		tbl.Size1=tbl.Size1 Vector3.new(5,5,5)
		tbl.Size2=tbl.Size2 or Vector3.new(5,5,5)
		tbl.StartCF=tbl.StartCF or CFrame.new()
		tbl.LifeTime=(tbl.LifeTime or 100)
		tbl.Shape=tbl.Shape or "Part"
		tbl.sbm = tbl.sbm or 1
		tbl.mbm = tbl.mbm or 1
		tbl.b1 = 1+tbl.mbm/50
		tbl.b2 = 1+tbl.sbm/50
		tbl.radX = tbl.radX or 0
		tbl.radY = tbl.radY or 0
		tbl.radZ = tbl.radZ or 0
		tbl.Size2=tbl.Size2 or Vector3.new()
		tbl.Transparency1=tbl.Transparency1 or 0
		tbl.Transparency2=tbl.Transparency2 or 0
		local Part = newpart()
		Part.CanCollide = false
		Part.CanTouch = false
		Part.CanQuery = false
		Part.Anchored = true
		Part.Name = ""
		Part.CFrame = tbl.StartCF or CFrame.new()
		Part.Size = tbl.DSize or tbl.Size1 or Vector3.new()
		Part.Transparency = tbl.Transparency1  or 0
		Part.Color =  tbl.DColor  or tbl.Color1 or Color3.new()
		Part.Material = tbl.DMaterial  or tbl.Material  or Enum.Material.Neon
		Part.Reflectance = tbl.Reflectance or 0
		if tbl.MoveTo then
			if tbl.Boomerang then
				tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime*tbl.b1
			else
				tbl.MovingSpeed=(tbl.StartCF.p - tbl.MoveTo.p).Magnitude/tbl.LifeTime
			end
		end
		if tbl.Boomerang then
			tbl.EndSize=(tbl.Size1 - tbl.Size2)*tbl.b2
		else
			tbl.EndSize=(tbl.Size1 - tbl.Size2)
		end
		tbl.EndTransparency=tbl.Transparency1-tbl.Transparency2
		table.insert(ActiveEffects, {
			["Part"] = Part,
			[2] = tbl,
			Index = 1
		}) end)
end

local LightningBolt = {}

function Module.Effect.clear()
	for data in pairs(ActiveEffects) do
		destroy(data.Part)
	end
	table.clear(ActiveEffects)
end
function Module.Effect.Lightning(Table)
	assert(Table.Start, "Start is nil")
	assert(Table.End, "Start is nil")
	Table.Curve = Table.Curve or 0
	Table.Radius = Table.Radius or 0
	Table.LifeTime = Table.LifeTime or 1
	local A1, A2 = {}, {}
	A1.WorldPosition, A1.WorldAxis = Table.Start.p, Vector3.new()
	A2.WorldPosition, A2.WorldAxis = Table.End.p, Vector3.new()
	local self = LightningBolt.new(A1, A2, Table.Segments or 10, workspace.Terrain)
	self.Enabled = true 
	self.Attachment0, self.Attachment1 = A1, A2
	if Table.ProperCurve then
		self.CurveSize0, self.CurveSize1 = Table.Curve1 or 0,Table.Curve2 or 0
	else
		self.CurveSize0, self.CurveSize1 = -Table.Curve or 0,Table.Curve or 0
	end
	self.MinRadius, self.MaxRadius = -Table.Radius or 0, Table.Radius or 0
	self.Frequency = Table.Frequency or 1
	self.AnimationSpeed = Table.AnimationSpeed or 0
	self.Thickness = Table.Thickness or 1
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = Table.MinThickness or 1, Table.MaxThickness or 1
	self.MinTransparency, self.MaxTransparency = 0, 1
	self.PulseSpeed = Table.LifeTime or 1
	self.PulseLength = Table.LifeTime or 1
	self.FadeLength = Table.LifeTime*2 or 2
	self.ContractFrom = Table.LifeTime*20 or 20
	self.Color = Table.Color or Color3.new()
end

ArtificialHB.Event:Connect(function(DeltaTime)
	for i in pairs(tospin) do
		i.CFrame=i.CFrame*tospin[i]
		if not i:IsDescendantOf(game) then
			tospin[i]=nil
		end
	end

	for i, Data in pairs(ActiveEffects) do
		local p=Data.Part
		local tbl = Data[2]
		local acttime = tbl.LifeTime
		if tbl.Boomerang then
			p.Size=p.Size-(Vector3.new((tbl.EndSize.X)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Y)*((1 - (Data.Index/acttime)*tbl.b2)),(tbl.EndSize.Z)*((1 - (Data.Index/acttime)*tbl.b2)))*tbl.b2)/acttime
			p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
			p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
			if tbl.Color2 then
				p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
			end
			if tbl.MoveTo ~= nil then
				local a = p.Orientation
				p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-(tbl.MovingSpeed)*((1-(Data.Index/acttime)*tbl.b1)))
				p.Orientation = a
			end
		else
			p.Size=p.Size-tbl.EndSize/acttime/2
			p.Transparency = p.Transparency - tbl.EndTransparency/acttime/2
			p.CFrame=p.CFrame*CFrame.Angles(math.rad(tbl.radX),math.rad(tbl.radY),math.rad(tbl.radZ))
			if tbl.Color2 then
				p.Color = tbl.Color1:Lerp(tbl.Color2, Data.Index/acttime/2)
			end
			if tbl.MoveTo ~= nil then
				local a = p.Orientation
				p.CFrame = CFrame.new(p.Position,tbl.MoveTo.p)*CFrame.new(0,0,-tbl.MovingSpeed/2)
				p.Orientation = a
			end
		end
		if Data.Index >= (acttime * 2)+1 then
			table.remove(ActiveEffects, i)
			destroy(p)
		end
		Data.Index=Data.Index+1
	end
end)



local clock = os.clock


function DiscretePulse(input, s, k, f, t, min, max) --input should be between 0 and 1. See https://www.desmos.com/calculator/hg5h4fpfim for demonstration.
	return math.clamp( (k)/(2*f) - math.abs( (input - t*s + 0.5*(k)) / (f) ), min, max )
end

function NoiseBetween(x, y, z, min, max)
	return min + (max - min)*(math.noise(x, y, z) + 0.5)
end

function CubicBezier(p0, p1, p2, p3, t)
	return p0*(1 - t)^3 + p1*3*t*(1 - t)^2 + p2*3*(1 - t)*t^2 + p3*t^3
end
local rng = Random.new()
local xInverse = CFrame.lookAt(Vector3.new(), Vector3.new(1, 0, 0)):inverse()

local ActiveBranches = {}

LightningBolt.__index = LightningBolt

--Small tip: You don't need to use actual Roblox Attachments below. You can also create "fake" ones as follows:

function LightningBolt.new(Attachment0, Attachment1, PartCount,parent)
	local self = setmetatable({}, LightningBolt)

	--Main (default) Properties--

	--Bolt Appearance Properties--
	self.Enabled = true --Hides bolt without destroying any parts when false
	self.Attachment0, self.Attachment1 = Attachment0, Attachment1 --Bolt originates from Attachment0 and ends at Attachment1
	self.CurveSize0, self.CurveSize1 = 0, 0 --Works similarly to beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png
	self.MinRadius, self.MaxRadius = 0, 2.4 --Governs the amplitude of fluctuations throughout the bolt
	self.Frequency = 1 --Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning
	self.AnimationSpeed = 7 --Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)
	self.Thickness = 1 --The thickness of the bolt
	self.MinThicknessMultiplier, self.MaxThicknessMultiplier = 0.2, 1 --Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt

	--Bolt Kinetic Properties--
	--Allows for fading in (or out) of the bolt with time. Can also create a "projectile" bolt
	--Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)
	--Works by passing a "wave" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)
	--See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties
	self.MinTransparency, self.MaxTransparency = 0, 1 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseSpeed = 2 --Bolt arrives at Attachment1 1/PulseSpeed seconds later. See https://www.desmos.com/calculator/hg5h4fpfim
	self.PulseLength = 1000000 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.FadeLength = 0.2 --See https://www.desmos.com/calculator/hg5h4fpfim
	self.ContractFrom = 0.5 --Parts shorten or gro
	self.Color = Color3.new(1, 1, 1) --Can bw once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441

	--Bolt Color Properties--e a Color3 or ColorSequence
	self.ColorOffsetSpeed = 3 --Sets speed at which ColorSequence travels along Bolt

	--

	self.Parts = {} --The BoltParts which make up the Bolt


	local a0, a1 = Attachment0, Attachment1
	local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*self.CurveSize0, a1.WorldPosition - a1.WorldAxis*self.CurveSize1, a1.WorldPosition
	local PrevPoint, bezier0 = p0, p0
	local MainBranchN = PartCount or 30

	for i = 1, MainBranchN do
		local t1 = i/MainBranchN
		local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
		local NextPoint = i ~= MainBranchN and (CFrame.lookAt(bezier0, bezier1)).Position or bezier1
		local BPart = newpart()
		BPart.Anchored = true
		BPart.Color = Color3.new(1, 1, 1)
		BPart.CanTouch, BPart.CanQuery = false, false
		BPart.Material = Enum.Material.Neon
		BPart.Transparency = 1
		BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, 0, 0)
		BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
		BPart.Locked, BPart.CastShadow = true, false
		self.Parts[i] = BPart
		PrevPoint, bezier0 = NextPoint, bezier1
	end

	self.PartsHidden = false
	self.DisabledTransparency = 1
	self.StartT = clock()
	self.RanNum = math.random()*100
	self.RefIndex = #ActiveBranches + 1

	ActiveBranches[self.RefIndex] = self

	return self
end

function LightningBolt:Destroy()
	ActiveBranches[self.RefIndex] = nil

	for i = 1, #self.Parts do
		destroy(self.Parts[i])
		task.spawn(function()
			task.wait()
			table.remove(self.Parts, i)
		end)
		if i%100 == 0 then wait() end
	end
	task.spawn(function()
		repeat task.wait() until #self.Parts == 0
		table.clear(self)
		self = nil
	end)
end

local offsetAngle = math.cos(math.rad(90))
game:GetService("RunService").Heartbeat:Connect(function ()
	for _, ThisBranch in pairs(ActiveBranches) do
		if ThisBranch.Enabled == true then
			ThisBranch.PartsHidden = false
			local MinOpa, MaxOpa = 1 - ThisBranch.MaxTransparency, 1 - ThisBranch.MinTransparency
			local MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius
			local thickness = ThisBranch.Thickness
			local Parts = ThisBranch.Parts
			local PartsN = #Parts
			local RanNum = ThisBranch.RanNum
			local StartT = ThisBranch.StartT
			local spd = ThisBranch.AnimationSpeed
			local freq = ThisBranch.Frequency
			local MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier
			local a0, a1, CurveSize0, CurveSize1 = ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1
			local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition + a0.WorldAxis*CurveSize0, a1.WorldPosition - a1.WorldAxis*CurveSize1, a1.WorldPosition
			local timePassed = clock() - StartT
			local PulseLength, PulseSpeed, FadeLength = ThisBranch.PulseLength, ThisBranch.PulseSpeed, ThisBranch.FadeLength
			local Color = ThisBranch.Color
			local ColorOffsetSpeed = ThisBranch.ColorOffsetSpeed
			local contractf = 1 - ThisBranch.ContractFrom
			local PrevPoint, bezier0 = p0, p0

			if timePassed < (PulseLength + 1) / PulseSpeed then

				for i = 1, PartsN do
					--local spd = NoiseBetween(i/PartsN, 1.5, 0.1*i/PartsN, -MinAnimationSpeed, MaxAnimationSpeed) --Can enable to have an alternative animation which doesn't shift the noisy lightning "Texture" along the bolt
					local BPart = Parts[i]
					local t1 = i/PartsN
					local Opacity = DiscretePulse(t1, PulseSpeed, PulseLength, FadeLength, timePassed, MinOpa, MaxOpa)
					local bezier1 = CubicBezier(p0, p1, p2, p3, t1)
					local time = -timePassed --minus to ensure bolt waves travel from a0 to a1
					local input, input2 = (spd*time) + freq*10*t1 - 0.2 + RanNum*4, 5*((spd*0.01*time) / 10 + freq*t1) + RanNum*4
					local noise0 = NoiseBetween(5*input, 1.5, 5*0.2*input2, 0, 0.1*2*math.pi) + NoiseBetween(0.5*input, 1.5, 0.5*0.2*input2, 0, 0.9*2*math.pi)
					local noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)*math.exp(-5000*(t1 - 0.5)^10)
					local thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)
					local NextPoint = i ~= PartsN and (CFrame.new(bezier0, bezier1)*CFrame.Angles(0, 0, noise0)*CFrame.Angles(math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)), 0, 0)*CFrame.new(0, 0, -noise1)).Position or bezier1

					if Opacity > contractf then
						BPart.Size = Vector3.new((NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(0.5*(PrevPoint + NextPoint), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					elseif Opacity > contractf - 1/(PartsN*FadeLength) then
						local interp = (1 - (Opacity - (contractf - 1/(PartsN*FadeLength)))*PartsN*FadeLength)*(t1 < timePassed*PulseSpeed - 0.5*PulseLength and 1 or -1)
						BPart.Size = Vector3.new((1 - math.abs(interp))*(NextPoint - PrevPoint).Magnitude, thickness*thicknessNoise*Opacity, thickness*thicknessNoise*Opacity)
						BPart.CFrame = CFrame.lookAt(PrevPoint + (NextPoint - PrevPoint)*(math.max(0, interp) + 0.5*(1 - math.abs(interp))), NextPoint)*xInverse
						BPart.Transparency = 1 - Opacity
					else
						BPart.Transparency = 1
					end

					if typeof(Color) == "Color3" then
						BPart.Color = Color
					else --ColorSequence
						t1 = (RanNum + t1 - timePassed*ColorOffsetSpeed)%1
						local keypoints = Color.Keypoints 
						for i = 1, #keypoints - 1 do --convert colorsequence onto lightning
							if keypoints[i].Time < t1 and t1 < keypoints[i+1].Time then
								BPart.Color = keypoints[i].Value:lerp(keypoints[i+1].Value, (t1 - keypoints[i].Time)/(keypoints[i+1].Time - keypoints[i].Time))
								break
							end
						end
					end

					PrevPoint, bezier0 = NextPoint, bezier1
				end

			else

				ThisBranch:Destroy()

			end

		else --Enabled = false

			if ThisBranch.PartsHidden == false then
				ThisBranch.PartsHidden = true
				local datr = ThisBranch.DisabledTransparency
				for i = 1, #ThisBranch.Parts do
					ThisBranch.Parts[i].Transparency = datr
				end
			end

		end
	end

end)

local function animate(cfs, cf, alpha)
	if(typeof(cfs) == "table")then
		for i, v in next, cfs do
			offsets[i] = offsets[i]:Lerp(origoffsets[i] * v, .1)
		end
	else
		offsets[cfs] = offsets[cfs]:Lerp(origoffsets[cfs] * cf, alpha)
	end
end

function radiananglefrom(range)
	return CFrame.Angles(math.rad(math.random(-range,range)),math.rad(math.random(-range,range)),math.rad(math.random(-range,range)))
end

function randomtable(t)
	return t[math.random(#t)]
end

function randomangle()
	return CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360))
end

function mrandom(a,b)
	return Random.new():NextNumber(a or -1,b or 1)
end

function cfoffset(range)
	return CFrame.new((mrandom(-range,range)),mrandom(-range,range),mrandom(-range,range))
end

function DrawPoint(A,B)
	local Distance = (A-B).Magnitude
	return CFrame.new(A, B)*CFrame.new(0,0,-Distance/2), Distance
end
function PointLightning(Start, End, Segments, Offset)
	local Points = {}
	for i = 0, Segments do
		local Offset = Vector3.new(mrandom(-Offset,Offset),mrandom(-Offset,Offset),mrandom(-Offset,Offset))
		if i == 0 or i == Segments then
			Offset = Vector3.new()
		end
		table.insert(Points, 
			Start + (End - Start).Unit * i * (End - Start).Magnitude/Segments + Offset
		)
	end
	return Points, Offset
end


local Bezier = (function()
	-- Bezier
	-- Crazyman32
	-- April 1, 2015

	-- Modified January 28, 2016
	-- Optimized for Quadratic and Cubic cases
	-- Clarified documentation for GetPath()

	-- Modified December 5, 2017
	-- Added method 'GetLength()'
	-- Added method 'GetPathBySegmentLength()'
	-- Added method 'GetPathByNumberSegments()'

--[[

METHODS:

	b = Bezier.new(thisModule)
	
	Vector3          b:Get(ratio)
	Array<Vector3>   b:GetPath(step)
	Array<Vector3>   b:GetPathBySegmentLength(segmentLength)
	Array<Vector3>   b:GetPathByNumberSegments(numSegments)
	Number           b:GetLength([step])
	Array<Vector3>   b:GetPoints()

-------------------------------------------------------------------------------------------


EXAMPLES AND DOCUMENTATION:

-------------------------------------------------------------------------------------------

local Bezier = require(thisModule)

local b = Bezier.new(Vector3 pointA, Vector3 pointB, Vector3 pointC, ...)
	> Create a new bezier object
	> Must input at least 3 Vector3 points, or else it will throw an error
	
	> TIP: Do not create multiple objects with the same order and set of
	       points. Doing so would be pointless. Reuse the object when you can.
	
	> If 3 points are given, the module is optimized automatically for the quadratic case
	> If 4 points are given, the module is optimized automatically for the cubic case

-------------------------------------------------------------------------------------------

b:Get(ratio)
	> Get a Vector3 position on the curve with the given ratio
	> Ratio should be between 0 and 1
		> 0 = Starting point
		> 1 = Ending point
		> 0.5 = 50% along the path
		> 0.2 = 20% along the path
		> etc.

local positionStart = b:Get(0)
local positionMid   = b:Get(0.5)
local positionEnd   = b:Get(1)

-------------------------------------------------------------------------------------------

b:GetPathBySegmentLength(segmentLength)
	> Create a path along the curve, where the segments are roughly 'segmentLength' long
	> Returns a table of Vector3 positions

-------------------------------------------------------------------------------------------

b:GetPathByNumberSegments(numSegments)
	> Creates a path along the curve with 'numSegment' segments
	> Returns a table of Vector3 positions

-------------------------------------------------------------------------------------------

b:GetPath(step)
	> Create path along curve (returns table of Vector3 positions)
	> 'step' is the ratio step and should be within the range of (0, 1)

local path1 = b:GetPath(0.1) -- Higher resolution path
local path2 = b:GetPath(0.5) -- Lower resolution path

-------------------------------------------------------------------------------------------

b:GetLength([step])
	> Returns the length of a given path based on the step
	> 'step' is the ratio step and should be within the range of (0, 1). It defaults to 0.1
	> This is the same as calling 'b:GetPath(step)' and then summing up the distances
	  between each point. It is a rough approximation.

local length = b:GetLength()

-------------------------------------------------------------------------------------------

b:GetPoints()
	> Get the original control points that were inputted when object was created
	> Returns a table of Vector3 points

--]]





	-- NOTE: This was designed for higher-order bezier curves. However,
	--	has been optimized for quadratic and cubic cases. Curves of
	--	any degree can be calculated, but are not optimized above the
	--	cubic case.

	-- More info on Bezier Curves:
	-- http://en.wikipedia.org/wiki/Bezier_curve
	-- http://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm

	-- I recommend reading the Properties section for the first Wiki link


	-- This Bezier module was originally designed for my Bezier Path Plugin:
	-- http://www.roblox.com/item.aspx?id=232918839



	local Bezier = {}
	Bezier.__index = Bezier


	function Bezier.new(...)

		local points = {...}
		assert(#points >= 3, "Must have at least 3 points")

		local isQuadratic = (#points == 3)
		local isCubic = (#points == 4)

		local bezier = {}

		local V3 = Vector3.new
		local lerpV3 = V3().lerp

		local length = nil

		local lines = {}
		local numLines = 0
		local finalLine = nil
		-- Line index key:
		-- [1] = First point
		-- [2] = Second point
		-- [3] = Current Midpoint


		-- Create mutable pseudo-Vector3 points:
		local function CreatePoint(v3)
			--local point = {X = v3.X; Y = v3.Y; Z = v3.Z}
			local point = {v3.X, v3.Y, v3.Z}
			function point:ToVector3()
				return V3(self[1], self[2], self[3])
			end
			function point:lerp(other, ratio)
				return lerpV3(self:ToVector3(), other:ToVector3(), ratio)
			end
			return point
		end


		-- Initialize lines:
		if (not isQuadratic and not isCubic) then

			-- Initialize first lines:
			for i = 1,#points-1 do
				local p1 = CreatePoint(points[i])
				local p2 = CreatePoint(points[i + 1])
				local line = {p1, p2, CreatePoint(p1)}
				lines[#lines + 1] = line
			end

			local relativeLines = lines

			-- Initialize rest of lines:
			for n = #lines,2,-1 do
				local newLines = {}
				for i = 1,n-1 do
					local l1, l2 = relativeLines[i], relativeLines[i + 1]
					local line = {l1[3], l2[3], CreatePoint(l1[3])}
					newLines[i] = line
					lines[#lines + 1] = line
				end
				relativeLines = newLines
			end

			finalLine = relativeLines[1]

			numLines = #lines

		end


		-- Get a point on the curve with the given ratio:
		if (isQuadratic) then

			local p0, p1, p2 = points[1], points[2], points[3]

			-- Quadratic solution:
			function bezier:Get(r, clampRatio)
				if (clampRatio) then
					r = (r < 0 and 0 or r > 1 and 1 or r)
				end
				return (1-r)*(1-r)*p0+2*(1-r)*r*p1+r*r*p2
			end

		elseif (isCubic) then

			local p0, p1, p2, p3 = points[1], points[2], points[3], points[4]

			-- Cubic solution:
			function bezier:Get(r, clampRatio)
				if (clampRatio) then
					r = (r < 0 and 0 or r > 1 and 1 or r)
				end
				return (1-r)*(1-r)*(1-r)*p0+3*(1-r)*(1-r)*r*p1+3*(1-r)*r*r*p2+r*r*r*p3
			end

		else

			function bezier:Get(ratio, clampRatio)
				if (clampRatio) then
					ratio = (ratio < 0 and 0 or ratio > 1 and 1 or ratio)
				end
				-- Any degree solution:
				for i = 1,numLines do
					local line = lines[i]
					local mid = line[1]:lerp(line[2], ratio)
					local pt = line[3]
					pt[1], pt[2], pt[3] = mid.X, mid.Y, mid.Z
				end
				return finalLine[3]:ToVector3()
			end

		end


		-- Approximated length:
		function bezier:GetLength(step)
			if (not length) then
				local path = self:GetPath(step or 0.1)
				local l = 0
				for i = 2,#path do
					local dist = (path[i - 1] - path[i]).Magnitude
					l = (l + dist)
				end
				length = l
			end
			return length
		end


		-- Get a path of the curve with the given step:
		-- Returns a table of Vector3 points
		function bezier:GetPath(step)
			assert(type(step) == "number", "Must provide a step increment")
			-- Check step domain is within interval (0.0, 1.0):
			assert(step > 0 and step < 1, "Step out of domain; should be between 0 and 1 (exclusive)")
			local path = {}
			local lastI = 0
			for i = 0,1,step do
				lastI = i
				path[#path + 1] = self:Get(i)
			end
			-- In case 'step' didn't fill path fully, properly handle last remaining point:
			if (lastI < 1) then
				local overrideLast = ((1 - lastI) < (step * 0.5))
				path[#path + (overrideLast and 0 or 1)] = self:Get(1)
			end
			return path
		end


		function bezier:GetPathByNumberSegments(numSegments)
			assert(type(numSegments) == "number", "Must provide number of segments")
			assert(numSegments > 0, "Number of segments must be greater than 0")
			return self:GetPath(1 / numSegments)
		end


		function bezier:GetPathBySegmentLength(segmentLength)
			assert(type(segmentLength) == "number", "Must provide a segment length")
			assert(segmentLength > 0, "Segment length must be greater than 0")
			local length = self:GetLength()
			local numSegments = length / segmentLength
			return self:GetPathByNumberSegments(math.floor(numSegments + 0.5))
		end


		-- Get the control points (the original Vector3 arguments passed to create the object)
		function bezier:GetPoints()
			return points
		end


		return setmetatable(bezier, Bezier)

	end



	return Bezier
end)()

function chat(msg)
	pcall(function()
		if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then
			game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(msg)
		else
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
		end
	end)
end


local Billboards = {}
function Speak(str)
	local len = str:len()
	local bb = Instance.new("BillboardGui", workspace)
	bb.Adornee = workspace.Terrain
	bb.StudsOffsetWorldSpace = (Movement.Position*CFrame.new(0,1.5,0)).Position
	local tl = Instance.new("TextLabel", bb)
	bb.Size = UDim2.new(len/2,0,1,0)
	tl.Size = UDim2.new(1,0,1,0)
	tl.BackgroundTransparency = 1
	tl.Font = Enum.Font.Gotham
	tl.TextColor3 = Color3.new(1, 1, 1)
	tl.TextScaled = true
	local ustroke = Instance.new("UIStroke", tl)
	ustroke.Thickness = 1
	ustroke.Color = Color3.new(1, 0.333333, 0)
	table.insert(Billboards, bb)
	local txt = ""
	local old = Billboards[(table.find(Billboards, bb)-1)]
	if old  then
		bb.StudsOffset = old.StudsOffset + Vector3.new(0,1,0)
	else
		bb.StudsOffset = Vector3.new(0,2,0)
	end
	task.delay((str:len()/10)+4,function()
		if bb  then
			bb:Destroy()
			table.remove(Billboards,table.find(Billboards,bb))
			bb=nil
		end
	end)

	for i = 1, len do
		local a, b = utf8.graphemes(str, i,i)()
		local char = str:sub(a,b)
		local tim = .06
		if char == "." then
			tim = .4
		end
		if char == "," or char == ";" then
			tim = .25
		end
		txt=txt..char
		tl.Text = txt
		PlaySound("rbxassetid://1130200908", Movement.Position*CFrame.new(0,1.5,0), Random.new():NextNumber(.8,1.1),10)
		task.wait(tim)
		if i == len then
			task.wait(3)
			local tw = game:GetService("TweenService"):Create(tl, TweenInfo.new(1), {TextTransparency = 1})
			tw:Play()
			game:GetService("TweenService"):Create(ustroke, TweenInfo.new(1), {Transparency = 1}):Play()
			tw.Completed:Connect(function()
				bb:Destroy()
				table.remove(Billboards,table.find(Billboards,bb))
				bb=nil
			end)
			while bb and bb:IsDescendantOf(game) do
				bb.StudsOffset = bb.StudsOffset+Vector3.new(mrandom(-.3,.3),mrandom(-.3,.3),mrandom(-.3,.3))
				tl.Rotation = tl.Rotation+mrandom(-3,3)
				task.wait()
			end
		end
	end
end

ArtificialHB.Event:Connect(function()
	for i,v in ipairs(Billboards) do
		v.StudsOffsetWorldSpace = (Movement.Position*CFrame.new(0,1.5,0)).Position
	end
end)

if(game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.LegacyChatService)then
	plr.Chatted:Connect(Speak)
else
	game:GetService("TextChatService").SendingMessage:Connect(function(m)
		Speak(m.Text)
	end)
	game:GetService("TextChatService").TextChatCommands.RBXEmoteCommand.Triggered:Connect(function(a, b)
		Speak(b)
	end)
end

local function actualchat(str)
	local split = str:split(".")
	for i, v in next, split do
		if(v ~= "")then
			chat(v..".")
			task.wait(v:len()/13)
		end
	end
end

local cooldown = false

local usingarmR = true
local usingarmL = true
local usingtorso = true
local disableanim = false

local lookmouse = false
local switching = false
local cangun = false
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe or cooldown)then return end
	if(io.KeyCode == Enum.KeyCode.E)then
		if Movement.Falling then
			return
		end
		walkspeed=0
		cooldown = true
		lookmouse = true
		usingarmL = false
		local c;c=ArtificialHB.Event:Connect(function()
			animate({
				["Left Arm"] = CFrame.new(0,1.1,-.5)*CFrame.Angles(math.rad(120),0,0)
			})
		end)
		task.wait(.6)
		c:Disconnect()
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = parts
		local allc = math.random(20,30)
		for i = 1, allc do
			local hit = mouse.Hit
			task.wait(.02)
			task.spawn(function()
				local dest = (Movement.Position*cfoffset(.7)).p
				task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest)*randomangle(),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(1,1,5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=15,radX=mrandom(-12,12),radY=mrandom(-12,12),radZ=mrandom(-12,12)}) end)
				local p = Movement.Position*CFrame.new(mrandom(-4,4),mrandom(8,15),mrandom(-4,4))
				local spread = Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
				local dir = (CFrame.new(p.p,hit.p).LookVector.Unit*1000 + spread*70)
				local hitray = workspace:Raycast(p.p, dir, params)
				local hit = hit
				local Normal = Vector3.new(0,1,0)
				if hitray then
					hit=CFrame.new(hitray.Position)
					Normal = hitray.Normal
				else
					hit = CFrame.new(p.p + dir)
				end
				local a = newpart()
				a.CFrame = CFrame.new(p.p, Movement.Position.p)
				a.Size=Vector3.new()
				a.Material="Glass"
				a.Color=Color3.new(1, 0.3, 0)
				a.Anchored=true
				a.CastShadow=false
				a.CastShadow=false
				a.CanQuery=false
				a.CanCollide=false
				task.spawn(function()
					local last = p.p
					local Points = PointLightning(p.p,Movement.Position.p, 8/3, .5)

					for i,v in ipairs(Points) do
						local Point, Distance = DrawPoint(last, v)
						task.spawn(function()
							Module.Effect.TW({
								StartProps = {
									CFrame=Point,
									Color=Color3.new(1,.15,0),
									Size=Vector3.new(),
									Material = "Glass"
								},
								TweenList = {
									{
										TweenInfo={.5},
										TweenProperties={Size=Vector3.new(.5,.5,Distance)},
										Settings = {Yield=true}
									},
									{
										TweenInfo={.5,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
										TweenProperties={Transparency=1,Size=Vector3.new(0,0,Distance)},
										Settings = {Yield=true}
									},
								},
							}) end)
						last=v
						if i == #Points  then
							task.spawn(function() Module.Effect.new({StartCF=CFrame.new(dest),Shape="Ball",Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(2.5,2.5,2.5),Color1=Color3.new(1, 0.333333, 0),Color2=Color3.new(1, 0.333333, 0),Transparency2=1,LifeTime=35}) end)
						end
						PlaySound("rbxassetid://4307214211", Point, mrandom(.8,1.2), .2)
						task.wait(.05)
					end
				end)

				tween(a, {.5}, {Size=Vector3.new(.5,.5,2)}).Completed:Wait()
				tween(a, {.5}, {CFrame=CFrame.new(p.p, hit.p)}).Completed:Wait()
				p = CFrame.new(p.p, hit.p)
				local dis = (p.p - hit.p).Magnitude



				if math.random(2)==1 then
					task.wait(.3)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)

					task.spawn(function() Module.Effect.new({StartCF=CFrame.new(p.p, hit.p) * CFrame.new(0,0,-dis/2), Size1=Vector3.new(0,0,dis),Size2=Vector3.new(1,1,dis),Boomerang=true,Transparency2=1,Material="Glass",Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(0.5, 0, 0),LifeTime=25}) end)

				else
					task.wait(.3)
					local rm=tween(a, {.4}, {Transparency=1,Size=a.Size*1.5})
					rm.Completed:Connect(function()
						destroy(a)
					end)
					PlaySound("rbxassetid://1624609598", p, mrandom(.6,1.4), 2)
					local last = p.p
					local wawa=  Vector3.new(mrandom(-1,1),mrandom(-1,1),mrandom(-1,1))
					local Points = PointLightning(p.p,hit.p, 25/3, 1)

					for i,v in ipairs(Points) do
						task.spawn(function()
							local Point, Distance = DrawPoint(last, v)
							last=v
							task.spawn(function()
								Module.Effect.TW({
									StartProps = {
										CFrame=p,
										Color=Color3.new(.5,0,0),
										Size=Vector3.new(.5,.5,0),
										Material="Glass"
									},
									TweenList = {
										{
											TweenInfo={1.5},
											TweenProperties={Transparency=0,Size=Vector3.new(.5,.5,Distance),CFrame=Point},
											Settings = {Yield=true}
										},
										{
											TweenInfo={i / #Points},
											TweenProperties={Transparency=1},
											Settings = {Yield=true}
										},
									},
								}) end)
							if i == #Points then
								task.wait(1.5)
								PlaySound("rbxassetid://3778610036", Point, mrandom(.7,.9), 4)
								for i = 1, math.random(4,6) do
									task.spawn(function() Module.Effect.new({StartCF=CFrame.new(Point.p, Point.p - Normal)*CFrame.new(mrandom(-3,3),mrandom(-1,1),mrandom(-3,3)),Size1=Vector3.new(),Size2=Vector3.new(3,5,3)*2,Transparency2=1,Color1=Color3.new(0.5, 0, 0),Color2=Color3.new(1,1,1),Material="Glass",Shape="Ball",LifeTime=60,radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Boomerang=true}) end)
								end

								for i,v in ipairs(checkregion(hit.p, 5)) do
									task.spawn(function()
										if(not kill(v))then return end
										task.spawn(function()
											local a = newpart()
											a.CanCollide=  false
											a.CanQuery = false
											a.Anchored=  true
											a.CastShadow=false
											a.CFrame=v.CFrame 
											a.Color=Color3.new(0.5,0,0)
											a.Size=v.Size
											a.Material="Glass"
											tween(a, {1}, {CFrame=v.CFrame*CFrame.new(0,mrandom(5,8),0),Transparency=1}).Completed:Wait()
											destroy(a)
										end)


										Module.Effect.TW({
											Shape = randomtable({"Ball", "Part"}),
											StartProps = {
												CFrame=v.CFrame*randomangle(),
												Color=Color3.new(1,.15,0),
												Size=Vector3.new(.4,4,.4),
											},
											TweenList = {
												{
													TweenInfo={3},
													TweenProperties={Transparency=1,Color=Color3.new()},
												},
												{
													TweenInfo={2},
													TweenProperties={Position=v.Position+cfoffset(8).p},
													Settings = {Yield=true,Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))}

												},
												{
													TweenInfo={2,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
													TweenProperties={Position=v.Position},
													Settings = {Yield=true}

												},
											},
										})
									end)
								end
							end
						end)
					end
				end
			end)
		end
		usingarmL = true
		lookmouse = false
		task.delay(.6,function()
			walkspeed=30
			cooldown = false
		end)
	elseif(io.KeyCode == Enum.KeyCode.Q)then
		if (Movement.Position.p-mouse.Hit.p).Magnitude>1000 then
			return
		end
		local mo = mouse.Hit * mouse.Hit.Rotation:Inverse()
		cooldown = true
		PlaySound("rbxassetid://6162449120",mo,mrandom(.8,1), 2)
		local pos = CFrame.new(mo.p+Vector3.new(0,1.5*2,0))*Movement.Position.Rotation
		Movement.Position = pos
		task.delay(.15,function()
			cooldown = false
		end)
		mo=mo+Vector3.new(0,1.5*2,0)
		task.spawn(function() Module.Effect.TW({
			StartProps = {
				CFrame=mo,
				Color=Color3.new(0, 1, 0),
				Size=Vector3.new(5,12,5)/3,
				Material = "Neon",
				Transparency=.7
			},
			TweenList = {
				{
					TweenInfo={1},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},
				{
					TweenInfo={.9},
					TweenProperties={Size=Vector3.new(5,12,5),Color=Color3.new()},
					Settings = {Yield=true}
				},

				{
					TweenInfo={.6},
					TweenProperties={Size=Vector3.new(),Color=Color3.new(),CFrame=mo*CFrame.new(0,-3,0)*randomangle()},
					Settings = {Yield=true}
				},
			},
			}) end)
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0),Transparency1=.3, LifeTime=20, Size1=Vector3.new(),Size2=Vector3.new(20,1,20),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})
		Module.Effect.new({StartCF=mo*CFrame.new(0,-3,0), LifeTime=15,Transparency1=.3, Size1=Vector3.new(1,0,1),Size2=Vector3.new(1,30,1),Transparency2=1,Color1=Color3.new(0,1,0),Shape="Ball"})

		local parts = checkregion(mo.p, 8)
		for j,v in ipairs(parts) do
			task.spawn(function()
				if(not kill(v))then return end
				for i,face in ipairs(Enum.NormalId:GetEnumItems()) do
					local Size = v.Size
					local CF = v.CFrame

					if face == Enum.NormalId.Top or face ==  Enum.NormalId.Bottom then
						Size = Vector3.new(v.Size.X,0,v.Size.Z)
						CF = CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.Y/2)
					elseif face == Enum.NormalId.Front or face == Enum.NormalId.Back then
						Size = Vector3.new(v.Size.X, v.Size.Y, 0)
						CF = CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.Z/2)
					else
						Size = Vector3.new(0, v.Size.Y, v.Size.Z)
						CF =CF * CFrame.new(Vector3.FromNormalId(face)*v.Size.X/2)
					end
					Module.Effect.TW({
						StartProps = {
							CFrame=CF,
							Color=v.Color,
							Size=Size,
							Material = v.Material,
							Transparency=v.Transparency,
							TopSurface = v.TopSurface,
							RightSurface = v.RightSurface,
							LeftSurface = v.LeftSurface, 
							FrontSurface = v.FrontSurface,
							BackSurface = v.BackSurface,
							BottomSurface = v.BottomSurface,
							CastShadow = v.CastShadow
						},
						TweenList = {
							{
								TweenInfo={1.6+(j/#parts)+(i/6)},
								TweenProperties={Size=Size},
								Settings = {Yield=true}
							},
							{
								TweenInfo={3,Enum.EasingStyle.Quad,Enum.EasingDirection.In},
								TweenProperties={Position=v.Position+cfoffset(6+v.Size.Magnitude).p,Transparency=1},
								Settings = {Yield=true,Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))}
							},
						},
					})

				end
			end)
		end
	elseif(io.KeyCode == Enum.KeyCode.G)then
		if Movement.Walking or switching then
			return
		end
		switching = true
		walkspeed = 0
		cangun=not cangun

		if not cangun then
			for ind = 1, 60, 3 do
				for i, v in next, transparency do
					if(i:find("Gun"))then
						transparency[i] = (origtransparency[i] - 1) + (ind/60)
					end
				end
				for i, v in next, limbs do
					if(i:find("Gun"))then
						v.Transparency = transparency[i]
					end
				end
				task.wait()
			end
			for i, v in next, transparency do
				if(i:find("Gun"))then
					transparency[i] = origtransparency[i]
				end
			end
			for i, v in next, limbs do
				if(i:find("Gun"))then
					v.Transparency = transparency[i]
				end
			end
		else
			for ind = 1, 60, 3 do
				for i, v in next, transparency do
					if(i:find("Gun"))then
						transparency[i] = origtransparency[i] - (ind/60)
					end
				end
				for i, v in next, limbs do
					if(i:find("Gun"))then
						v.Transparency = transparency[i]
					end
				end
				task.wait()
			end
			for i, v in next, transparency do
				if(i:find("Gun"))then
					transparency[i] = origtransparency[i] - 1
				end
			end
			for i, v in next, limbs do
				if(i:find("Gun"))then
					v.Transparency = transparency[i]
				end
			end
		end

		task.wait(.3)
		walkspeed = 30
		switching = false
	elseif(io.KeyCode == Enum.KeyCode.Z)then
		if (Movement.Position.p-mouse.Hit.p).Magnitude>1000 or Movement.Falling or Movement.Walking or not cangun then
			return
		end
		cooldown = true
		lookmouse = true
		walkspeed=0
		disableanim = true
		local c;c= ArtificialHB.Event:Connect(function()
			animate("Head",CFrame.new(0,0,math.rad(5))*CFrame.Angles(math.rad(10),0,0),.2)
			animate("Torso",CFrame.new()*CFrame.Angles(math.rad(14),0,0),.2)
			animate("Right Arm",CFrame.new(-.4,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(-15)),.2)
			animate("Left Arm",CFrame.new(1,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(50)),.2)
			animate("Right Leg",CFrame.new(0,0,math.rad(14))*CFrame.Angles(math.rad(-14),0,0),.2)
			animate("Left Leg",CFrame.new(0,0,math.rad(20))*CFrame.Angles(math.rad(-20),0,0),.2)
			animate("Gun",CFrame.new(.6,-.3,0)*CFrame.Angles(0,math.rad(-15),0)*CFrame.new(-1.1,0,0),.2)
		end)
		task.wait(.6)
		c:Disconnect()
		local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
		PlaySound("rbxassetid://7378960134", Barrel, mrandom(.8,1.2), 2)
		task.spawn(function()
			local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
			local last = Barrel.p
			local awog = (Barrel*CFrame.new(-1.5*2,0,0)*cfoffset(1.5))
			local lastb = Barrel.p
			local Points = PointLightning(Barrel.p,awog.p, 18, .6)
			local lt = .5
			local Points2 = PointLightning(Barrel.p,awog.p, 18, .6) 
			local waa = {}
			for i,v in ipairs(Points2) do
				local Point, Distance = DrawPoint(lastb, v)
				waa[i] = {Point, Distance}
				lastb = v
			end
			--				--	Color3.fromHSV(0.05, 1, math.random())
			Module.Effect.new({StartCF=Barrel*randomangle(),Material="Glass",Size1=Vector3.new(0,0,.8),Size2=Vector3.new(.4,.4,.8),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1})
			for i,v in ipairs(Points) do
				local Point, Distance = DrawPoint(last, v)
				task.spawn(function() Module.Effect.TW({
					StartProps = {
						CFrame=Point,
						Color=Color3.fromHSV(0.05, 1, math.random()),
						Size=Vector3.new(.5,.5,Distance),
						Transparency=1
					},
					TweenList = {
						{
							TweenInfo={lt/1.5},
							TweenProperties={Transparency=0,Size=Vector3.new(.05,.05,Distance)},
							Settings = {Yield=true}
						},
						{
							TweenInfo={lt*1.5},
							TweenProperties={Transparency=1},
						},
						{
							TweenInfo={lt/2},
							TweenProperties={Size=Vector3.new(.15,.15,Distance)},
							Settings = {Yield=true}
						},
						{
							TweenInfo={lt*4},
							TweenProperties={Size=Vector3.new(.15,.15,waa[i][2]),CFrame=waa[i][1]},
							Settings = {Yield=true}
						},
					},
					}) end)
				last=v
				if i == #Points or i == 1   then
					Module.Effect.new({StartCF=Point*CFrame.new(0,0,-Distance/2)*randomangle(),Material="Glass",Size1=Vector3.new(0,0,.8),Size2=Vector3.new(.4,.4,.8),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1})
				end
				task.wait(.03)
			end
		end)
		lookmouse = false
		Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(2.5,2.5,2.5),radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Color2=Color3.new(),LifeTime=15,Transparency2=1})
		Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(2.5,2.2+.5,2.5),radX=mrandom(-2,2),radY=mrandom(-2,2),radZ=mrandom(-2,2),Color2=Color3.new(),LifeTime=20,Transparency2=1,Shape="Ball"})
		for i = 1, 3 do
			Module.Effect.new({StartCF=Barrel*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(.15,14,.15),radX=mrandom(-12,12),radY=mrandom(-12,12),radZ=mrandom(-12,12),Color2=Color3.new(),LifeTime=23,Transparency2=1,Shape="Ball"})
		end
		task.spawn(function()
			local hit = mouse.Hit
			local dis = (Barrel.p-hit.p).Magnitude
			local ha = 30+math.clamp(dis/100, 0, 20)
			local bez = Bezier.new(Barrel.p,Barrel.p + Vector3.new(0,ha/4,0), hit.p + Vector3.new(0,ha*1.5 ,0),hit.p)
			local path = bez:GetPath(.2 - math.clamp(dis/1000, 0, .05))
			local last = Barrel.p
			local increase = 0
			for i,v in ipairs(path) do
				increase=increase+.3
				local Offset = cfoffset(increase).p
				if i == #path then
					Offset=Vector3.new()
					for i,v in ipairs(checkregion(v, 12)) do
						task.spawn(function()
							if(not kill(v))then return end
							local a = newpart()
							a.Size=v.Size
							a.CFrame=v.CFrame
							a.Color=Color3.new(1,mrandom(.1,.3),0)
							a.Material="Neon"
							a.Anchored=true
							tween(a, {6+math.random()},{Transparency=1,Color=Color3.new()}).Completed:Connect(function()
								destroy(a)
							end)
							task.delay(2,function()
								a.Anchored=false
							end)
						end)
					end
				end
				v=v+Offset
				local thickness = 1
				local Point,Distance = DrawPoint(last,v)
				Module.Effect.new({StartCF=Point*CFrame.Angles(math.rad(90),math.rad(90),0),Shape="Cylinder",Color1=Color3.new(1, .4,0),Color2=Color3.new(),Transparency2=1,Size1=Vector3.new(thickness,Distance,thickness),Size2=Vector3.new(0,Distance,0),LifeTime=20})
				local lt = 1
				last=v


				if i == #path then
					task.spawn(function()
						local hit = hit*hit.Rotation:Inverse()
						for i = 1, math.random(14,27) do

							Module.Effect.new({StartCF=hit, Size1=Vector3.new(0,.1,0),Color1=Color3.new(1, .5,0),Color2=Color3.new(),Shape="Ball",Size2=Vector3.new(9,.1,9),Transparency2=1,LifeTime=25})
							local whereto = hit.p+Vector3.new(mrandom(-35,35),0,mrandom(-35,35))
							task.spawn(function()
								local wcf = CFrame.new(whereto)
								local dis = (hit.p - whereto).Magnitude
								local incr = math.random(4)
								local bez = Bezier.new(hit.p,hit.p + Vector3.new(0,dis*incr,0), whereto + Vector3.new(0,dis*incr ,0),whereto)
								local amo = .03
								if dis < 5  then
									amo = .01
								end
								local path = bez:GetPath(.1)
								local last = hit.p

								for i,v in ipairs(path) do
									local Point, Distance = DrawPoint(last, v)
									Module.Effect.new({StartCF=Point*CFrame.Angles(math.rad(90),math.rad(90),0),Size1=Vector3.new(1,Distance,1), Shape = "Cylinder", Color1=randomtable({Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.2,0), Color3.new(1,.35,0)}), Color2=Color3.new(),Size2=Vector3.new(0,Distance,0), LifeTime=25,Transparency2=1})
									last=v

									if i == #path then
										PlaySound("rbxassetid://4307214211", wcf, mrandom(.8,1.2), .6)
										PlaySound("rbxassetid://3750957896", wcf, mrandom(.8,1.2), .8, 0)
										Module.Effect.new({StartCF=wcf*randomangle(), Color1=Color3.new(1,.3,0),Transparency2=1,Color2=Color3.new(),Size1=Vector3.new(),Size2=Vector3.new(20,20,20),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),LifeTime=30})
										Module.Effect.new({Shape="Ball",StartCF=wcf*randomangle(), Color1=Color3.new(1,.3,0),Transparency2=1,Color2=Color3.new(),Size1=Vector3.new(),Size2=Vector3.new(23,23,23),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),LifeTime=35})
										for i = 1, math.random(3,6) do
											Module.Effect.new({StartCF=wcf*randomangle(),Size1=Vector3.new(),Color1=Color3.new(1, 0.333333, 0),Size2=Vector3.new(1,60,1),radX=mrandom(-9,9),radY=mrandom(-9,9),radZ=mrandom(-9,9),Color2=Color3.new(),LifeTime=35,Transparency2=1,Shape="Ball",Transparency1=.3})
										end
										for i = 1, math.random(3) do
											Module.Effect.new({StartCF=wcf*randomangle(),Shape="Ball",Size1=Vector3.new(),Size2=Vector3.new(3,8,3),Color1=Color3.new(1,.15,0),Color2=Color3.new(1,.15,0),Transparency2=1,LifeTime=35,radX=mrandom(-3,3),radY=mrandom(-3,3),radZ=mrandom(-3,3), MoveTo=wcf*cfoffset(10)})
										end
										for i,v in ipairs(checkregion(v, 12)) do
											task.spawn(function()
												if(not kill(v))then return end
												local a = newpart()
												a.Size=v.Size
												a.CFrame=v.CFrame
												a.Color=Color3.new(1,mrandom(.1,.3),0)
												a.Material="Neon"
												a.Anchored=true
												tween(a, {6+math.random()},{Transparency=1,Color=Color3.new()}).Completed:Connect(function()
													destroy(a)
												end)
												task.delay(2,function()
													a.Anchored=false
												end)
											end)
										end
									end
									task.wait(amo)
								end
							end)

							task.wait(.15)
						end
					end)
				end
				task.wait(.03)
			end
		end)
		local c;c= ArtificialHB.Event:Connect(function()
			animate("Head",CFrame.new(0,0,math.rad(5))*CFrame.Angles(math.rad(10),0,0),.2)
			animate("Torso",CFrame.new()*CFrame.Angles(math.rad(14),0,0),.2)
			animate("Right Arm",CFrame.new(-.7,1,-1)*CFrame.Angles(math.rad(160),math.rad(-35),math.rad(-15)),.6)
			animate("Left Arm",CFrame.new(1,1,-1.15)*CFrame.Angles(math.rad(130),0,math.rad(50)),.6)
			animate("Right Leg",CFrame.new(0,0,math.rad(14))*CFrame.Angles(math.rad(-14),0,0),.2)
			animate("Left Leg",CFrame.new(0,0,math.rad(20))*CFrame.Angles(math.rad(-20),0,0),.2)
			animate("Gun",CFrame.new(.6,-.3,0)*CFrame.Angles(math.rad(25),math.rad(-15),0)*CFrame.new(-1.1,0,0),.6)
		end)
		task.wait(.09)
		c:Disconnect()

		disableanim = false

		walkspeed=30
		task.delay(.4,function()
			cooldown = false
		end)
	elseif(io.KeyCode == Enum.KeyCode.Six)then
		actualchat([[It's happened. Do not send to recipient. Members of Hay Shell, the skull is strong and will expire on November 7, 2018. Many participants complain about the approval of the demonstrations. This is a sign that many people have signed up with their new friends. Send more to see if a member works. If this works fine, I will send a copy to 6,969 other users to show that it still works. I am the first to be eligible for those who have researched more. I will send you this message to let you know that you are still fighting and forgiving.]])
	elseif(io.KeyCode == Enum.KeyCode.Seven)then
		actualchat([[Hello May i ask you for a question. Can you make me a glitcher. It has customization of wings animations attacks and keys. and you can also customize attacks like wind like shockwaves or like dust effects. and you can do lots for things in customs like make it banisher glitcher or kickisher. and a few other things like rename changes and tails and then you can do other things for a attacks you can raise a island and make it fall down with a shockwave. or for chaos make rocks fly up to form a ball kinda and push them down and stab them with the axe. and other attacks like summon a giant ball like snake banisher v3 and v2. and for a M form you float in the air and a black ball surrounds you and grows or a attack or a attack you fly up shoot a beam and for a X or you could do other attacks. if you could that would make me happy.]])
	elseif(io.KeyCode == Enum.KeyCode.Zero)then
		local function dec(b)local _=#b do local f={} for a,_ in pairs(('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='):split(''))do f[_:byte()]=a-1 end local a=_ local d,e=table.create(math.floor(a/4)+1),1 local _=b:sub(-2)=='=='and 2 or b:sub(-1)=='='and 1 or 0 for _=1,_>0 and a-4 or a,4 do local c,b,a,_=b:byte(_,_+3) local _=f[c]*262144+f[b]*4096+f[a]*64+f[_] d[e]=string.char(bit32.extract(_,16,8),bit32.extract(_,8,8),bit32.extract(_,0,8)) e=e+1 end if _==1 then local b,_,a=b:byte(a-3,a-1) local _=f[b]*262144+f[_]*4096+f[a]*64 d[e]=string.char(bit32.extract(_,16,8),bit32.extract(_,8,8))elseif _==2 then local a,_=b:byte(a-3,a-2) local _=f[a]*262144+f[_]*4096 d[e]=string.char(bit32.extract(_,16,8))end b=table.concat(d)end local a=1 local function n(_)local _={string.unpack(_,b,a)} a=table.remove(_) return table.unpack(_)end local _=n('B') local m=n('B') m={bit32.extract(m,6,2)+1,bit32.extract(m,4,2)+1,bit32.extract(m,2,2)+1,bit32.extract(m,0,2)+1,bit32.band(_,1)>0} local i=('I'..m[1]) local g=('I'..m[2]) local _=('I'..m[3]) local c=('I'..m[4]) local b=n(i) local j=table.create(b) local d={} local a={[1]=function(_)return n('s'.._)end,[2]=function(_)return _~=0 end,[3]=function()return n('d')end,[4]=function(_,_)table.insert(d,{_,n(('I'..m[1]):rep(3))})end,[5]={CFrame.new,m[5]and'dddddddddddd'or'ffffffffffff'},[6]={Color3.fromRGB,'BBB'},[7]={BrickColor.new,'I2'},[8]=function(_)local _=n('I'.._) local a=table.create(_) for _=1,_ do a[_]=ColorSequenceKeypoint.new(n('f'),Color3.fromRGB(n('BBB')))end return ColorSequence.new(a)end,[9]=function(_)local _=n('I'.._) local a=table.create(_) for _=1,_ do a[_]=NumberSequenceKeypoint.new(n(m[5]and'ddd'or'fff'))end return NumberSequence.new(a)end,[10]={Vector3.new,m[5]and'ddd'or'fff'},[11]={Vector2.new,m[5]and'dd'or'ff'},[12]={UDim2.new,m[5]and'di2di2'or'fi2fi2'},[13]={Rect.new,m[5]and'dddd'or'ffff'},[14]=function()local _=n('B') local a={"Top","Bottom","Left","Right","Front","Back"} local c={} for b=0,5 do if bit32.extract(_,b,1)==1 then table.insert(c,Enum.NormalId[a[b+1]])end end return Axes.new(unpack(c))end,[15]=function()local _=n('B') local a={"Top","Bottom","Left","Right","Front","Back"} local c={} for b=0,5 do if bit32.extract(_,b,1)==1 then table.insert(c,Enum.NormalId[a[b+1]])end end return Faces.new(unpack(c))end,[16]={PhysicalProperties.new,m[5]and'ddddd'or'fffff'},[17]={NumberRange.new,m[5]and'dd'or'ff'},[18]={UDim.new,m[5]and'di2'or'fi2'},[19]=function()return Ray.new(Vector3.new(n(m[5]and'ddd'or'fff')),Vector3.new(n(m[5]and'ddd'or'fff')))end} for c=1,b do local _=n('B') local b=bit32.band(_,31) local _=(_-b)/32 local a=a[b] if type(a)=='function'then j[c]=a(_,c)else j[c]=a[1](n(a[2]))end end for _,_ in pairs(d)do j[_[1]]=CFrame.fromMatrix(j[_[2]],j[_[3]],j[_[4]])end local a=n(g) local f={} local e={} for b=1,a do local _=j[n(i)] local l local k,h if _=="UnionOperation"then l=DecodeUnion(j,m,n) l.UsePartColor=true elseif _:find("Script")then l=Instance.new("Folder") Script(l,_=='ModuleScript')elseif _=="MeshPart"then l=Instance.new("Part") k=Instance.new("SpecialMesh") k.MeshType=Enum.MeshType.FileMesh k.Parent=l else l=Instance.new(_)end local d=f[n(g)] local a=n(c) local _=n(c) f[b]=l for _=1,a do local a,b=j[n(i)],j[n(i)] local _=false if k then if a=="MeshId"then k.MeshId=b _=true elseif a=="TextureID"then k.TextureId=b _=true elseif a=="Size"then if not h then h=b else k.Scale=b/h end elseif a=="MeshSize"then if not h then h=b k.Scale=l.Size/b else k.Scale=h/b end _=true end end if(not _)then l[a]=b end end if k then if k.MeshId==''then if k.TextureId==''then k.TextureId='rbxasset://textures/meshPartFallback.png'end k.Scale=l.Size end end for _=1,_ do l:SetAttribute(j[n(i)],j[n(i)])end if not d then table.insert(e,l)else l.Parent=d end end local _=n(_) for _=1,_ do local _,a,b=n(g),n(i),n(g) f[_][j[a]]=f[b]end return e end
		local unrealityparticle=dec('AAAoIQRQYXJ0IQhBbmNob3JlZCIhDUJvdHRvbVN1cmZhY2UDAAAAAAAAAAAhBkNGcmFtZQQMJyghCkNhbkNvbGxpZGUCIQhDYW5Ub3VjaCEIUG9zaXRpb24KAAAAAAAASMIAAAAAIQRTaXplCgAA+kMAAPpDAAD6QyEKVG9wU3VyZmFjZSEMVHJhbnNwYXJlbmN5AwAA'..'AAAAAPA/IQ9QYXJ0aWNsZUVtaXR0ZXIhDEFjY2VsZXJhdGlvbgoAAAAAAADwQQAAAAAhBUNvbG9yKAIAAAAAAAAAAACAPwAAACEITGlmZXRpbWURAAAgQQAAoEEhBFJhdGUDAAAAAGXNzUEhCFJvdFNwZWVkEQAAIMEAACBBIQhSb3RhdGlvbhEAALTDAAC0QykCAAAA'..'AAAAAEAAAAAAAACAPwAAAAAAAAAAIQVTcGVlZBEAAPBBAADwQSELU3ByZWFkQW5nbGULAAC0wgAAtEIpAgAAAAAAAAAAAAAAAAAAgD8AAIA/AAAAACEHWk9mZnNldAMAAAAAAABZQAoAAIA/AAAAAAAAAAAKAAAAAAAAgD8AAAAAAgEACQACAwQFBgcICQoJCwwNDg8F'..'EBESAQsAExQVFhcYGRobHB0eDR8gISIjECQlJgA=')[1]

		task.spawn(chat, "I'LL PUT AN END TO EVERYTHING")

		PlaySound("rbxassetid://265201042", workspace.CurrentCamera.CFrame, math.random(80, 110)/100, 5)
		task.wait(1)
		task.spawn(chat, "FLAWLESSLY AND BRUTALLY.")
		PlaySound("rbxassetid://6925598641", workspace.CurrentCamera.CFrame, math.random(80, 110)/100, 5)

		local fade = Instance.new("ScreenGui", plr.PlayerGui)
		fade.ResetOnSpawn = false
		fade.IgnoreGuiInset = true
		local white = Instance.new("Frame", fade)
		white.BackgroundColor3 = Color3.new(1,1,1)
		white.Size = UDim2.fromScale(2, 2)
		white.BackgroundTransparency = 1
		game:GetService("TweenService"):Create(white, TweenInfo.new(.3, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut, 0, true), {
			BackgroundTransparency = 0
		}):Play()
		task.delay(.6, pcall, game.Destroy, fade)

		task.wait(.5)
		local tonepitch = math.random(90, 110)/100
		local time = 6.877*tonepitch

		local cc = Instance.new("ColorCorrectionEffect", game:GetService("Lighting"))
		cc.TintColor = Color3.fromRGB(50, 50, 50)
		cc.Contrast = -2
		game:GetService("TweenService"):Create(cc, TweenInfo.new(time, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut), {
			TintColor = Color3.new(1,1,1),
			Contrast = 0
		}):Play()
		task.delay(time, pcall, game.Destroy, cc)

		local p = unrealityparticle:Clone()
		p.Parent = workspace.Terrain
		local con = game:GetService("RunService").RenderStepped:Connect(function()
			p.Position = workspace.CurrentCamera.CFrame.Position - Vector3.new(0, 100, 0)
		end)
		task.delay(time, pcall, function()
			p.ParticleEmitter.Enabled = false
			task.wait(20)
			pcall(game.Destroy, p)
		end)
		task.delay(time, pcall, con.Disconnect, con)

		PlaySound("rbxassetid://3262620486", workspace.CurrentCamera.CFrame, tonepitch, 2+math.random(90, 110)/100)
		PlaySound("rbxassetid://2785493", workspace.CurrentCamera.CFrame, math.random(90, 110)/100, 4+math.random(90, 110)/100)

		local instances = {}
		local ended = false
		local ontime = os.clock()

		if(workspace:FindFirstChild("Everything"))then
			syncapi:InvokeServer('Remove', {workspace.Everything})
		end

		local connection
		connection = game:GetService("RunService").Heartbeat:Connect(function(dt)
			if ended then connection:Disconnect() return end

			if os.clock() - ontime >= 1/30 then			
				local killme = {}

				for i,v in workspace:GetDescendants() do
					if v:IsA("BasePart") and v.Name ~= "Terrain" then
						if v ~= plr.Character and not plr.Character:IsAncestorOf(v) and not v:IsDescendantOf(workspace.Terrain) then
							table.insert(killme,{
								Part = v;
								Size = Vector3.zero;
								CFrame = CFrame.new(9e9,9e9,9e9)
							})
						end
					end
				end

				ontime = os.clock()
				task.spawn(syncapi.InvokeServer, syncapi, 'SyncResize', killme)
			end
		end)

		task.wait(time)
		ended = true
		task.wait()

		for i, v in next, instances do
			pcall(game.Destroy, v)
		end
		table.clear(instances)
	end
end)

local holdingmouse = false
mouse.Button1Down:Connect(function()
	holdingmouse = true
end)
mouse.Button1Up:Connect(function()
	holdingmouse = false
end)

local increment = 0
function getXAndZPositions(angle, radius)
	local x = math.cos(angle) * radius
	local z = math.sin(angle) * radius
	return x, z
end
function shootgun()		
	if not cangun or Movement.Walking then return end
	if cooldown then
		return
	end
	increment=math.clamp(increment+.05, 0, .21)
	lookmouse = true
	cooldown = true
	usingarmR = false
	usingarmL = false
	usingtorso = false
	walkspeed=0

	local c;c= ArtificialHB.Event:Connect(function()
		animate("Right Arm", CFrame.new(.3,.5,-.6)*CFrame.Angles(math.rad(90),0,math.rad(45)),.25)
		animate("Torso", CFrame.Angles(0,math.rad(45),0), .25)
		animate('Gun', CFrame.new(0,-.3,0)*CFrame.Angles(0,0,0),.25)
		animate("Left Arm",CFrame.new(math.rad(-3),0,0)*CFrame.Angles(0,0,math.rad(-6)), .25)
	end)
	task.wait(.15)

	c:Disconnect()
	local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
	PlaySound("rbxassetid://5773418559",Barrel, mrandom(.5,.7), 1.5)
	local P = Barrel
	local bolts = math.random(4,5)
	local distance = (Barrel.p-mouse.Hit.p).Magnitude
	local ori = mrandom(-360,360)
	local MaxBoltHeight = math.clamp(distance, 10, 80)
	local circ = 2 * math.pi
	local hit = mouse.Hit
	local exploding = false
	for i = 1, math.random(4,8) do
		task.spawn(function()
			local del = math.random()/6
			task.wait(del)
			local spread = cfoffset(6).p
			local gwa = CFrame.new(Barrel.p, hit.p+spread)*CFrame.new(0,0,-distance/1.2).Position+cfoffset(MaxBoltHeight).p

			local bez = Bezier.new(Barrel.p,gwa,hit.p+spread)
			local path = bez:GetPath(.2 - math.clamp(distance/1000, 0, .05))
			local last = Barrel.p
			local wa = .03 * math.clamp(distance / 100, 0, 2)
			local color = Color3.new(1,.3,0)
			if math.random(2)==1 then
				color = Color3.new(1,.3,.3)
			end
			for i,v in ipairs(path) do
				task.spawn(function()
					local offset = cfoffset(2).p
					if i == 1 or i == #path then
						offset=Vector3.new()
					end
					v=v+offset
					local lt = 1
					local Point, Distance = DrawPoint(last, v)
					task.spawn(function() Module.Effect.TW({
						StartProps = {
							CFrame=Point,
							Color=Color3.new(1,1,1),
							Size=Vector3.new(.3,.3,Distance)
						},
						TweenList = {
							{
								TweenInfo={lt},
								TweenProperties={Transparency=1,Color=color},
								Settings = {Yield=true}
							},
						},
						}) end)

					last=v

					if i==#path and not exploding then
						local 	hit=hit*hit.Rotation:Inverse()
						Point=Point*Point.Rotation:Inverse()
						exploding=true
						local wa = cfoffset(30)
						PlaySound("rbxassetid://3750957896", Point, mrandom(.6,.8), 4, 0)

						--time, style, direction, repeatcount, reverses
						local wh = CFrame.new(hit*cfoffset(30).p, hit.p)


						--effect2(StartProperties:{}, TweenList:{TweenInfo:{}, TweenProperties{}, TweenSettings:{Yield}})

						task.spawn(function() Module.Effect.TW({
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,.15,0),

							},
							TweenList = {
								{
									TweenInfo={4.5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1.4},
									TweenProperties={Size=Vector3.new(30,30,30)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={2},
									TweenProperties={Color=Color3.new()},
								},
								{
									TweenInfo={1.3,Enum.EasingStyle.Quart,Enum.EasingDirection.In},
									TweenProperties={Size=Vector3.new(0,50,0)},
									Settings = {Yield=true,MulSpin=8}
								}
							},
							Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))

							}) end)
						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(),
								Size = Vector3.new(4,5,6)

							},
							TweenList = {
								{
									TweenInfo={5.5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1.75},
									TweenProperties={Size=Vector3.new(20,20,20)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={3.3},
									TweenProperties={Size=Vector3.new(0,30,0),Color=Color3.new(1,1,1)},
									Settings = {Yield=true}
								}
							},
							Spin=CFrame.Angles(math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)),math.rad(mrandom(-1,1)))

							}) end)
						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,1,1),
								Size = Vector3.new(),
								Transparency=.1

							},
							TweenList = {
								{
									TweenInfo={4},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut,0,true},
									TweenProperties={Size=Vector3.new(50,50,60)},
								},
								{
									TweenInfo={.5},
									TweenProperties={Color=Color3.new(1,.3,.3)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={.5},
									TweenProperties={Color=Color3.new(1,.15,0)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={1.5},
									TweenProperties={Color=Color3.new()},
									Settings = {Yield=true}
								},
							},
							Spin=CFrame.Angles(math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)))

							}) end)


						task.spawn(function() Module.Effect.TW({
							Shape="Ball",
							StartProps = {
								CFrame=hit*randomangle(),
								Color=Color3.new(1,1,1),
								Size=Vector3.new(2,7,2)
							},
							TweenList = {
								{
									TweenInfo={5},
									TweenProperties={Transparency=1},
								},
								{
									TweenInfo={1},
									TweenProperties={Color=Color3.new(1,.15,0),Size=Vector3.new(30,30,30)},
									Settings = {Yield=true}
								},
								{
									TweenInfo={2},
									TweenProperties={CFrame=hit*cfoffset(40)*randomangle(),Size=Vector3.new(0,30,0)},
									Settings = {Yield=true}
								},
							},
							Spin=CFrame.Angles(math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)),math.rad(mrandom(-2,2)))

							})
						end)

						for i,v in ipairs(checkregion(hit.p, 25)) do
							task.spawn(function()
								if(not kill(v))then return end
								PlaySound(randomtable({"rbxassetid://4988577600","rbxassetid://4988577985","rbxassetid://4988578264"}),Point, mrandom(.8,1.2),2)
								local a= newpart()
								a.Anchored = false
								a.CFrame=v.CFrame
								a:BreakJoints()
								a.Color=v.Color
								a.Material=v.Material
								a.Size=v.Size
								task.delay(2,function()
									tween(a, {2},{Transparency=1}).Completed:Connect(function()
										destroy(a)
									end)
								end)
							end)
						end
					end
				end)
				task.wait(wa)
			end
		end)
	end
	local c;c= ArtificialHB.Event:Connect(function()
		animate("Right Arm", CFrame.new(.3,.7,-.6)*CFrame.Angles(math.rad(140),0,math.rad(45)),.3)
		animate("Torso", CFrame.Angles(0,math.rad(45),0), .3)
		animate('Gun', CFrame.new(0,-.3,0)*CFrame.Angles(0,0,0),.3)
	end)
	task.wait(.06)
	c:Disconnect()
	task.delay(.2-increment,function()
		cooldown = false
		lookmouse = false
		usingarmR = true
		usingarmL = true
		usingtorso = true
		walkspeed=30
		task.delay(.1,function()
			if lookmouse == false then
				increment = 0
			end
		end)
	end)
end

local dt = 0
local Sine = 0
ArtificialHB.Event:Connect(function()
	if(plr.Character)then
		plr.Character:PivotTo(CFrame.new(9e9, 9e9, 9e9))
	end

	Sine = os.clock()*60

	if(Movement.Flying)then
		if math.random(9)==1 then
			task.spawn(function() Module.Effect.new({
				StartCF=Movement.Position*CFrame.new(0,-3,0)*radiananglefrom(3),
				Size1=Vector3.new(20,.5,20),
				Size2=Vector3.new(0,.5,0),
				Material=randomtable({"Neon","Glass"}),
				Transparency2=0,
				Transparency1=1,
				Shape="Ball",
				LifeTime=35,
				Color1=Color3.fromHSV(0.05, 1, math.random()),
				Color2=Color3.fromHSV(0.05, 1, math.random())
				})
			end)
		end
	end

	task.spawn(function()
		if(cangun)then
			if math.random(100)==1 then
				local Barrel = limbs["Gun_FadeB"].CFrame*CFrame.new(-.4,0,0)
				local last = Barrel.p
				local awog = (Barrel*CFrame.new(-1.5*2,-2,0)*cfoffset(3))
				local params = RaycastParams.new()
				params.RespectCanCollide = true
				params.FilterDescendantsInstances = parts
				params.FilterType = Enum.RaycastFilterType.Exclude
				local ray = workspace:Raycast(last, awog.p - last, params)
				if ray then
					awog = CFrame.new(ray.Position)
				end
				local lastb = Barrel.p
				local Points = PointLightning(Barrel.p,awog.p, 18/3, .6)
				local lt = .5
				local Points2 = PointLightning(Barrel.p,awog.p, 18/3, .6) 
				local waa = {}
				for i,v in ipairs(Points2) do
					local Point, Distance = DrawPoint(lastb, v)
					waa[i] = {Point, Distance}
					lastb = v
				end
				task.spawn(function() Module.Effect.new({StartCF=Barrel,Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(.8,.4,.4),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=25,Transparency2=1}) end)
				for i,v in ipairs(Points) do
					local Point, Distance = DrawPoint(last, v)
					task.spawn(function() Module.Effect.TW({
						StartProps = {
							CFrame=Point,
							Color=Color3.fromHSV(0.05, 1, math.random()),
							Size=Vector3.new(.5,.5,Distance),
							Transparency=1
						},
						TweenList = {
							{
								TweenInfo={lt/1.5},
								TweenProperties={Transparency=0,Size=Vector3.new(.05,.05,Distance)},
								Settings = {Yield=true}
							},
							{
								TweenInfo={lt*1.5},
								TweenProperties={Transparency=1},
							},
							{
								TweenInfo={lt/4},
								TweenProperties={Size=Vector3.new(.15,.15,Distance)},
								Settings = {Yield=true}
							},
							{
								TweenInfo={lt*4},
								TweenProperties={Size=Vector3.new(.15,.15,waa[i][2]),CFrame=waa[i][1]},
								Settings = {Yield=true}
							},
						},
						}) end)
					last=v
					if i == #Points then
						task.spawn(function() Module.Effect.new({StartCF=Point*CFrame.new(0,0,-Distance/2)*randomangle(),Material="Glass",Size1=Vector3.new(),Size2=Vector3.new(.2,.2,.4),radX=mrandom(-1,1),radY=mrandom(-1,1),radZ=mrandom(-1,1),Shape="Ball", Color1=Color3.fromHSV(0.05, 1, math.random()), Color2=Color3.fromHSV(0.05, 1, math.random()),Boomerang=false,LifeTime=50,Transparency2=1}) end)
					end
					task.wait(.03)
				end
			end
		end
	end)

	if(holdingmouse and not Movement.Falling and cangun)then
		shootgun()
	end

	if(lookmouse)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Vector3.new(mouse.Hit.X, Movement.Position.Y, mouse.Hit.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, mouse.Hit.Position)
		end
	end

	local anim = {}
	if(not disableanim)then
		if(not Movement.Walking and not Movement.Falling and not Movement.Jumping)then
			if cangun then
				local tiltam = .04
				animate("Head",CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),.1)
				if usingtorso then
					animate("Torso",CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0)*CFrame.new(0,0,.1)*CFrame.Angles(math.rad(-2)+.02*math.cos(Sine/25),math.rad(-15),math.rad(2)),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),.1)
				end
				animate("Right Leg",CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0),.1)
				animate("Left Leg",CFrame.new(),.1)
				if usingtorso then
					animate("Gun", CFrame.new(.6,-1.45,0)*CFrame.Angles(math.rad(-0),0,math.rad(70)), .3)
				end
			else
				local tiltam = .04
				animate("Head",CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),.1)
				if usingtorso then
					animate("Torso",CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),.1)
				end
				animate("Right Leg",CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0),.1)
				animate("Left Leg",CFrame.new(),.1)
			end
		end

		if(Movement.Jumping)then
			anim = {
				["Head"] = CFrame.new(0,0,.1)*CFrame.Angles(math.rad(15),0,0),
				Torso = CFrame.new()*CFrame.Angles(math.rad(6),0,0),
				["Right Arm"] = CFrame.new(.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(80)),
				["Left Arm"] = CFrame.new(-.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(-80)),
				["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-15),math.rad(5),0),
				["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
			}
			if cangun and usingtorso then
				animate("Gun", CFrame.new(), 1)
			end
		elseif(Movement.Falling)then
			anim = {
				["Head"] = CFrame.new(0,0,-.1)*CFrame.Angles(math.rad(-25),0,0),
				Torso = CFrame.new()*CFrame.Angles(math.rad(-15),0,0),
				["Right Arm"] = CFrame.new(.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(125)),
				["Left Arm"] = CFrame.new(-.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(-125)),
				["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-35),math.rad(5),0),
				["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
			}
			if cangun and usingtorso then
				animate("Gun", CFrame.new(), 1)
			end
		end

		if(Movement.Walking and not Movement.Jumping and not Movement.Falling)then
			if cangun then
				animate("Head",CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),.1)
				if usingtorso then
					animate("Torso",CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmR  then
					animate("Right Arm",CFrame.new(0,1.3,-.35)*CFrame.Angles(math.rad(145)-.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				end
				animate("Right Leg",CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				animate("Left Leg",CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				if usingtorso then
					animate("Gun",CFrame.new(), .3)
				end
			else
				animate("Head",CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),.1)
				if usingtorso then
					animate("Torso",CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),.1)
				end
				if usingarmR then
					animate("Right Arm",CFrame.new(0,0,0-(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				end
				if usingarmL then
					animate("Left Arm",CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
				end
				animate("Right Leg",CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),.1)
				animate("Left Leg",CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),.1)
			end
		end
	end

	if(not usingarmL)then
		anim["Left Arm"] = nil
	end
	if(not usingarmR)then
		anim["Right Arm"] = nil
	end
	if(not usingtorso)then
		anim["Torso"] = nil
	end

	animate(anim)

	cframes["Torso"] = Movement.Position*offsets["Torso"]
	cframes["Head"] = cframes["Torso"]*offsets["Head"]
	cframes["Right Arm"] = cframes["Torso"]*offsets["Right Arm"]
	cframes["Right Leg"] = cframes["Torso"]*offsets["Right Leg"]
	cframes["Left Arm"] = cframes["Torso"]*offsets["Left Arm"]
	cframes["Left Leg"] = cframes["Torso"]*offsets["Left Leg"]
	cframes["Gun"] = cframes["Right Arm"]*offsets["Gun"]
	cframes["Gun_FadeB"] = cframes["Right Arm"]*offsets["Gun"]*offsets["Gun_FadeB"]
	cframes["Gun_Crystal"] = cframes["Right Arm"]*offsets["Gun"]*offsets["Gun_Crystal"]
	cframes["Tail"] = cframes["Torso"]*offsets["Tail"]*CFrame.new(-math.rad(-15*math.cos(os.clock()*2)),0,0)*CFrame.Angles(0, math.rad(-10*math.cos(os.clock()*2)), 0):Inverse()
	cframes["Ears"] = cframes["Head"]*offsets["Ears"]*CFrame.Angles(math.rad(3*math.cos(os.clock())), math.rad(-5*math.cos(os.clock()*2)), math.rad(2*math.cos(os.clock()*1.3))):Inverse()

	for i, v in next, limbs do
		v.CFrame = cframes[i]
	end
end)

local lastrefit = 0
game:GetService("RunService").Heartbeat:Connect(function(delta)
	game:GetService("StarterGui"):SetCoreGuiEnabled("Chat", true)
	dt = dt + delta

	if(dt < 1/30)then
		return
	end
	dt = 0

	if(os.clock() - lastrefit >= .5)then
		lastrefit = os.clock()
		for i, v in next, {"Torso", "Left Arm", "Left Leg", "Head", "Right Arm", "Right Leg", "Gun", "Gun_FadeB", "Gun_Crystal", "Tail", "Ears"} do
			task.spawn(createlimb, v)
		end
	end

	local changecolor = {}
	local changematerial = {}
	local changeresize = {}
	local changemesh = {}
	for i, v in next, parts do
		local rep = replicatedparts[v]

		if(v.Color ~= rep.Color)then
			table.insert(changecolor, {
				Part = rep, Color = v.Color
			})
		end
		if(v.Material ~= rep.Material or v.Transparency ~= rep.Transparency or v.Reflectance ~= rep.Reflectance)then
			table.insert(changematerial, {
				Part = rep, Material = v.Material ~= rep.Material and v.Material or nil, Transparency = v.Transparency ~= rep.Transparency and v.Transparency or nil,
				Reflectance = v.Reflectance ~= rep.Reflectance and v.Reflectance or nil
			})
		end
		if(v.Size ~= rep.Size or v.CFrame ~= rep.CFrame)then
			table.insert(changeresize, {
				Part = rep, Size = v.Size, CFrame = v.CFrame
			})
		end
		local m, repm = v:FindFirstChildOfClass("SpecialMesh"), rep:FindFirstChildOfClass("SpecialMesh")
		if(m and repm)then
			if(m.MeshType ~= repm.MeshType or m.Scale ~= repm.Scale or m.MeshId ~= repm.MeshId)then
				table.insert(changemesh, {
					Part = rep, MeshType = m.MeshType ~= repm.MeshType and m.MeshType or nil,
					Scale = m.Scale ~= repm.Scale and m.Scale or nil,
					MeshId = m.MeshId ~= repm.MeshId and m.MeshId or nil
				})
			end
		end
	end
	if(#changeresize >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncResize', changeresize)
	end
	if(#changecolor >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncColor', changecolor)
	end
	if(#changematerial >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncMaterial', changematerial)
	end
	if(#changemesh >= 1)then
		task.spawn(syncapi.InvokeServer, syncapi, 'SyncMesh', changemesh)
	end
end)

if game:GetService("RunService"):IsStudio() then
	return
end
game:GetService("NetworkClient").ChildRemoved:Connect(function(v)
	if v.ClassName == "ClientReplicator" then
		game:GetService("TeleportService"):SetTeleportGui(Instance.new("ScreenGui"))
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId)
		game:GetService("TeleportService").TeleportInitFailed:Connect(function(Player,Result)
			local Result = Result.Value
			if Player ~= game:GetService("Players").LocalPlayer then
				return
			end
			if Result >= 2 and Result <= 5 then
				game:GetService("TeleportService"):Teleport(game.PlaceId)
			else
				local Start = tick()
				repeat
					game:GetService("RunService").RenderStepped:Wait()
				until tick()-Start >= 5
				game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId)
			end
		end)
	end
end)