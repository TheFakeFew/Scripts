local plr = game:GetService("Players").LocalPlayer
local btools;
local syncapi;

print'waiting'

repeat task.wait() until plr.Backpack:FindFirstChild("ServerEndpoint", true) and plr.Backpack:FindFirstChild("ServerEndpoint", true):IsA("RemoteFunction")

print'got sync'

syncapi = plr.Backpack:FindFirstChild("ServerEndpoint", true)
btools = syncapi.Parent.Parent

game:GetService("RunService").Heartbeat:Connect(function()
	btools.Parent = plr.Backpack
end)

local parts = {}

local Movement = {
	Position = CFrame.new(0, 5, 0),
	FakePosition = CFrame.new(0, 5, 0),
	MouseHit = CFrame.identity,
	Jumping = false,
	Falling = false,
	Walking = false,
	Flying = false,
}

local oldmainpos, walkspeed, gravityvelocity = Movement.Position, 30, 0
local w, a, s, d = false, false, false, false

local movementkeys = {
	w = function(up, io)
		w = not up
	end,
	a = function(up, io)
		a = not up
	end,
	s = function(up, io)
		s = not up
	end,
	d = function(up, io)
		d = not up
	end,
	f = function(up, io)
		if(not up)then
			Movement.Flying = not Movement.Flying
		end
	end,
	space = function(up, io)
		if(not up and not Movement.Falling and not Movement.Jumping and not Movement.Flying)then
			Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis/2)
			gravityvelocity = (1/60)*30
		end
	end,
}

local mouse = plr:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(false, io)
	end
end)

game:GetService("UserInputService").InputEnded:Connect(function(io, gpe)
	if(gpe)then return end

	local key = movementkeys[((io.UserInputType == Enum.UserInputType.MouseButton1)and("click")or(string.lower(io.KeyCode.Name)))]
	if(key)then
		key(true, io)
	end
end)

local campart = Instance.new("Part")
campart.Size = Vector3.zero
campart.Transparency = 1
campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)

game:GetService("RunService").RenderStepped:Connect(function(dt)
	if(not campart) or (not pcall(function()
			campart.Parent = nil
			campart.CFrame = campart.CFrame
		end))then
		pcall(game.Destroy, campart)
		campart = Instance.new("Part")
		campart.Size = Vector3.zero
		campart.Transparency = 1
		campart.CFrame = Movement.Position*CFrame.new(0,1.5,0)
	end
	pcall(function()
		workspace.CurrentCamera.CameraSubject = campart
	end)
end)

local realRotation = CFrame.identity
local momentum = 0
local momentummax = 40
local momentumspeed = 5
local walkingtime = os.clock()

local lastframe = os.clock()
local deltamult = 1

local function deltaclamp(val)
	return math.clamp(val*deltamult, 0, 1)
end

game:GetService("RunService").RenderStepped:Connect(function()
	deltamult = 60*(os.clock() - lastframe)
	lastframe = os.clock()
	campart.CFrame = campart.CFrame:Lerp(Movement.Position*CFrame.new(0,1.5,0), deltaclamp(.3))

	oldmainpos = Movement.Position
	local shiftlock =  game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter

	if(not Movement.Flying)then
		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {workspace.Terrain}
		local ray = workspace:Raycast(Movement.Position.Position, Movement.Position.Position-Vector3.new(0,6.3,0), param)
		if(ray)then
			Movement.Position = Movement.Position * CFrame.new(0,ray.Position.Y-Movement.Position.Y+3,0)
			gravityvelocity = 0
		else
			gravityvelocity = gravityvelocity - (((1/60)*1.4*(workspace.Gravity/196.2))*deltamult)
		end
	else
		gravityvelocity = 0
	end

	if(w or a or s or d)and(walkspeed>0)then
		Movement.Walking = true
	else
		Movement.Walking = false
		walkingtime = os.clock()
		momentum = 0
	end

	local fakewalkspeed = walkspeed

	if(Movement.Flying)then
		momentum = math.clamp((os.clock() - walkingtime) * momentumspeed, 0, momentummax)
	end
	fakewalkspeed = fakewalkspeed + momentum

	if(w and d)or(w and a)or(s and d)or(s and a)then
		fakewalkspeed = fakewalkspeed/1.4
	end

	local camlook = workspace.CurrentCamera.CFrame.LookVector

	if(Movement.Walking)and(not shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	elseif(shiftlock)then
		if(not Movement.Flying)then
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, 0, camlook.Z))
		else
			Movement.Position = CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(camlook.X, camlook.Y, camlook.Z))
		end
	end

	if(w)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(a)then
		Movement.Position = Movement.Position * CFrame.new(-Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end
	if(s)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.zAxis*(fakewalkspeed/60)*deltamult)
	end
	if(d)then
		Movement.Position = Movement.Position * CFrame.new(Vector3.xAxis*(fakewalkspeed/60)*deltamult)
	end

	if(not shiftlock)and(Movement.Position.X ~= oldmainpos.X)and(Movement.Position.Z ~= oldmainpos.Z)then
		Movement.Position = CFrame.new(Movement.Position.Position) * realRotation.Rotation

		if(Movement.Walking)and(not Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, 0, look.Z)), deltaclamp(math.pi/16))
		elseif(Movement.Walking)and(Movement.Flying)then
			local look = -CFrame.lookAt(Movement.Position.Position, oldmainpos.Position).LookVector
			Movement.Position = Movement.Position:Lerp(CFrame.lookAt(Movement.Position.Position, Movement.Position.Position+Vector3.new(look.X, look.Y, look.Z)), deltaclamp(math.pi/16))
		end

		realRotation = Movement.Position.Rotation
	end

	if(Movement.Position.Y < -200)then
		Movement.Position = CFrame.new(0,20,0)
		gravityvelocity = 0
	end

	Movement.Position = Movement.Position * CFrame.new(Vector3.yAxis*gravityvelocity)

	if(not Movement.Flying)then
		if(oldmainpos.Y > Movement.Position.Y)then
			Movement.Falling = true
			Movement.Jumping = false
		elseif(oldmainpos.Y < Movement.Position.Y)then
			Movement.Falling = false
			Movement.Jumping = true
		else
			Movement.Falling = false
			Movement.Jumping = false
		end
	else
		Movement.Falling = false
		Movement.Jumping = false
	end
end)

local limbs = {}
local cframes = {}

local sizes = {
	["Torso"] = Vector3.new(2, 2, 1),
	["Right Arm"] = Vector3.new(1, 2, 1),
	["Left Arm"] = Vector3.new(1, 2, 1),
	["Right Leg"] = Vector3.new(1, 2, 1),
	["Left Leg"] = Vector3.new(1, 2, 1),
	["Head"] = Vector3.new(1, 1, 1),
}
local colors = {
	["Torso"] = Color3.new(1, .3, .3)
}

local offsets = {
	["Torso"] = CFrame.identity,
	["Left Leg"] = CFrame.new(-.5, -2, 0),
	["Right Leg"] = CFrame.new(.5, -2, 0),
	["Right Arm"] = CFrame.new(1.5, 0, 0),
	["Left Arm"] = CFrame.new(-1.5, 0, 0),
	["Head"] = CFrame.new(0, 1.5, 0),
}
local origoffsets = table.clone(offsets)

local function createlimb(name)
	local limb = syncapi:InvokeServer('CreatePart', 'Normal', CFrame.identity, workspace.Terrain)
	limbs[name] = limb
	table.insert(parts, limb)

	limb.Material = Enum.Material.Glass
	limb.Transparency = .25
	limb.Anchored = true
	limb.Color = colors[name] or Color3.new(1,1,1)
	limb.Size = sizes[name] or Vector3.zero
	limb.CFrame = cframes[name] or CFrame.identity

	repeat task.wait() until limbs[name] ~= limb
	table.remove(parts, table.find(parts, limb))
	syncapi:InvokeServer('Remove', {limb})
end

local function animate(cfs)
	for i, v in next, cfs do
		offsets[i] = offsets[i]:Lerp(origoffsets[i] * v, .1)
	end
end

local Sine = 0
game:GetService("RunService").Heartbeat:Connect(function()
	if(plr.Character)then
		plr.Character:PivotTo(CFrame.new(9e9, 9e9, 9e9))
	end
	
	Sine = Sine + 1
	for i, v in next, {"Torso", "Left Arm", "Left Leg", "Head", "Right Arm", "Right Leg"} do
		task.spawn(createlimb, v)
	end

	local changes = {}
	for i, v in next, parts do
		table.insert(changes, {
			Part = v, Size = v.Size, CFrame = v.CFrame,
			Color = v.Color, Transparency = v.Transparency,
			Material = v.Material
		})
	end
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncResize', changes)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncColor', changes)
	task.spawn(syncapi.InvokeServer, syncapi, 'SyncMaterial', changes)
	
	cframes["Torso"] = Movement.Position*offsets["Torso"]
	cframes["Head"] = cframes["Torso"]*offsets["Head"]
	cframes["Right Arm"] = cframes["Torso"]*offsets["Right Arm"]
	cframes["Right Leg"] = cframes["Torso"]*offsets["Right Leg"]
	cframes["Left Arm"] = cframes["Torso"]*offsets["Left Arm"]
	cframes["Left Leg"] = cframes["Torso"]*offsets["Left Leg"]
	
	if(not Movement.Walking and not Movement.Falling and not Movement.Jumping)then
		local tiltam = .04
		animate({
			["Head"] = CFrame.new(0,0,tiltam/2+tiltam*math.cos(Sine/10))*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/10),0,0),
			Torso = CFrame.new()*CFrame.Angles(tiltam/2+tiltam*math.cos(Sine/20),0,0),
			["Right Arm"] = CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0-.05*math.cos(Sine/20),0),
			["Left Arm"] = CFrame.new(0,.05+.05*math.cos(Sine/20),0+.05*math.cos(Sine/20))*CFrame.Angles(0-.05*math.sin(Sine/20),0+.05*math.cos(Sine/20),0),
			["Left Leg"] = CFrame.new(),
			["Right Leg"] = CFrame.new(0,0,0+tiltam*math.cos(Sine/20))*CFrame.Angles(-tiltam/2-tiltam*math.cos(Sine/20),0,0)
		})
	end
	
	if(Movement.Jumping)then
		animate({
			["Head"] = CFrame.new(0,0,.1)*CFrame.Angles(math.rad(15),0,0),
			Torso = CFrame.new()*CFrame.Angles(math.rad(6),0,0),
			["Right Arm"] = CFrame.new(.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(80)),
			["Left Arm"] = CFrame.new(-.5,.7,0)*CFrame.Angles(math.rad(-5),0,math.rad(-80)),
			["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-15),math.rad(5),0),
			["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
		})
	elseif(Movement.Falling)then
		animate({
			["Head"] = CFrame.new(0,0,-.1)*CFrame.Angles(math.rad(-25),0,0),
			Torso = CFrame.new()*CFrame.Angles(math.rad(-15),0,0),
			["Right Arm"] = CFrame.new(.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(125)),
			["Left Arm"] = CFrame.new(-.5,1,0)*CFrame.Angles(math.rad(-5),0,math.rad(-125)),
			["Left Leg"] = CFrame.new(0,.6,-.3)*CFrame.Angles(math.rad(-35),math.rad(5),0),
			["Right Leg"] = CFrame.new(0,0,-.05)*CFrame.Angles(math.rad(-15),math.rad(-5),0)
		})
	end
	
	if(Movement.Walking and not Movement.Jumping and not Movement.Falling)then
		animate({
			["Head"] = CFrame.new(0,0,0)*CFrame.Angles(math.rad(9/2)-.05*math.cos(Sine/(25/4)),0+.04*math.sin(Sine/25),0+.04*math.cos(Sine/25)),
			Torso = CFrame.Angles(math.rad(-9)+.1*math.cos(Sine/(25/4)),0,0),
			["Right Arm"] = CFrame.new(0,0,0-(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0),
			["Left Arm"] = CFrame.new(0,0,0+(.7*1.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),
			["Left Leg"] = CFrame.new(0,.2+.5*math.cos(Sine/(25/4)),-.1-(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0+(.7*2.8)*math.sin(Sine/(25/4)),0+.2*math.cos(Sine/(25/4)),0),
			["Right Leg"] = CFrame.new(0,.2-.5*math.cos(Sine/(25/4)),-.1+(.7*2.5)*math.sin(Sine/(25/4)))*CFrame.Angles(0-(.7*2.8)*math.sin(Sine/(25/4)),0-.2*math.cos(Sine/(25/4)),0)
		})
	end
end)